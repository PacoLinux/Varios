/*M* EDICT - EXTRACTABLE DOCUMENTATION IN CRISMAN TERMS */
/*T***********************************************************/
/*T*                                                         */
/*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
/*T*                                                         */
/*T***********************************************************/
/*X*   PLM=2,STI=2,IND=2,CTI=4,DCI=5,PRB=YES,ECI=3,CSI=3,THI=2,
       IAD=2,DIN=2,ENI=4,CLM=0,CCC,MER=NO,CCE,SQB=YES,MCI=YES  */
/*P*
     NAME: Document
     PURPOSE:
          This program prompts the user for input for the *M* *P* *F* *I* *D*
          program documentation standards.
     DESCRIPTION:
          Using standard invocation syntax this program creates a separate file
          containing the document material.
          This documentation was created with this program!
     REFERENCE:
          Any problems?  see gary palmer .
*/
/*I*
     NAME: Promptfile
     PURPOSE:
          This routine does the structuring of the *M* document, since this
          section (*M*) must get special treatment.  The special treatment is
          due to the concatenation of name and description on a single line.
          It also alerts the documenter to the fact that his description or
          name or both are too long and will be truncated.  It also allows
          the user to alter the lines if truncation will occur.
     CALL:
          Call promptfile;
     DATA:
          This routine also structures the *P* document section.
     DESCRIPTION:
          Create the *M* and *P* documents.  Then ask if you want to document a
          module.
*/
/*I*
     NAME: Promptmod
     PURPOSE:
          Create the *F* and *D* documents.  It also asks if you want to
          document an internal module.
     CALL:
          Call promptmod;
     DATA:
          None.
     DESCRIPTION:
          Setup *F* and *D* and call internal module documenter, if wanted.
*/
/*I*
     NAME: Staristar
     PURPOSE:
          Do *I* document.
     CALL:
          Call staristar;
     DATA:
          None.
     DESCRIPTION:
          Setup *I*.
*/
/*I*
     NAME: Sethead
     PURPOSE:
          Set header of document module to open comment  and put out *_* and
          the name of the section being documented.
     CALL:
          Call sethead;
     DATA:
          None.
     DESCRIPTION:
          Creates the line of comments, the *_* where _ is the document type,
          and put out the name field for that section.
*/
/*I*
     NAME: Setend
     PURPOSE:
          To close comment stream.
     CALL:
          Call setend;
     DATA:
          None.
     DESCRIPTION:
          Outputs a * /
*/
/*I*
     NAME: SET_PROMPT
     PURPOSE:
          Set up a prompt field.
     CALL:
          Call SET_PROMPT(PROMPTEXT,LENTH);
     PARAMETERS:
          TEXT: the text to be used in the prompt.
          LENGTH: the length of the text.
     DATA:
          None.
     DESCRIPTION:
          Sets up the prompt to an input text of defined length.  The maximum
          length can be 15 characters.
*/
/*I*
     NAME: Dotext
     PURPOSE:
          Does the body of text for any subsection of a document type.  For
          example: it would create the paragraph/s  for purpose or call.
     CALL:
          Call DOTEXT(HEAD,P_FLEG);
     PARAMETERS:
          HEAD: Name of the subsection we are documenting.  Required parameter...
          P_FLAG: Indicate whether this is a required section or not. Optional
     DATA:
          None.
     DESCRIPTION:
          Sets up the section defined by head, if the input is nil and this is
          a required section,as defined by P_FLAG, the section will be created
          with the entry none.  If the section is not required then it will not
          appear at all in the  output file.  The input is accepted on a very
          long line so the user doesnt overflow the buffer too easily.  This
          routine will then take defined subsets of the user entered line
          making the line breaks in-between words.  These subsets will be
          treated as lines and output to the document file.   The remainder of
          the input line after all whole subsets are taken is returned to the
          user for edit corrections or additions.  This is done with a call to
          setext.
*/
/*I*
     NAME: Setext
     PURPOSE:
          Restructure input line into output file.
     CALL:
          Call setext (inputsize,linelen);
     PARAMETERS:
          INPUTSIZE: The number of characters in the input buffer.
          LINELEN: The length of an output line in the output file.
     DATA:
          None.
     DESCRIPTION:
          The buffer readbuf contains a large character string  whose length is
          defined by inputsize.  This routine goes out to a predefined
          position, defined by linelen, searches back to the first blank it can
          find, takes this chunk and places it into the output file.  This
          process is repeated until the section of input text left is smaller
          than the linelen.  This extra piece is then re-read to the terminal
          and user for additions/corrections.
*/
EDICT: PROC MAIN;
%INCLUDE CP_6;
%INCLUDE B$JIT;
%INCLUDE B_ERRORS_C;
 
%EQU INBUFSIZE = 231 ;
%EQU IOBUFSIZE = 132;
%EQU NOLINE =BITASC( '036'O);
%EQU CR =BITASC( '015'O);
%EQU LARGEST_KEY_LEN = 12;
%SUB REQUIRED = '1'B;
%SUB SET = '1'B;
%SUB NOTSET = '0'B;
 
%INCLUDE XU_MACRO_C;
%INCLUDE XU_PERR_C;
%INCLUDE EDICT_C61;
%PARSE$OUT (NAME = OPT$OUT,
 STCLASS = "BASED (BLK$)");
%PARSE$SYM (NAME = OPT$SYM,
 STCLASS = "BASED (BLK$)");
  DCL NSUBLKS UBIN;
  DCL OPT_NODE UBIN SYMREF;
  DCL X$PARSE ENTRY (1) ALTRET;
  DCL WORK (0:255) UBIN STATIC;
  DCL BLK$ PTR;
  DCL 1 BUF STATIC,
        2 L UBIN HALF HALIGNED,
        2 C CHAR (255) CALIGNED;
%P_PCB (NAME = OPT_PCB,
 STCLASS = STATIC,
 T = BUF.C,
 R = OPT_NODE,
 W = WORK,
 WSZ = 256);
 
  DCL BUPHER CHAR (130) STATIC;
%VLP_NAME (FPTN=HELP_NAME,
 NAME='EDICT');
  DCL M$LM DCB;
%VLR_HELP (FPTN=HELP_RES);
%FPT_HELP (FPTN=HELP_DOC,
 PROCNAME=HELP_NAME,
 BUF=BUPHER,
 RESULTS=HELP_RES,
 KEY1=KEY1,
 OUTDCB1=M$LO,
 SUBTOPIC=YES);
%VLP_NAME (FPTN=KEY1,
 LEN=31,
 NAME=' ');
  DCL HELP_TOPIC CHAR (31) CALIGNED STATIC;
  DCL HELP_LENGTH UBIN;
 
%VLP_NAME (FPTN=EDIT_NAME,
 NAME='EDIT');
  DCL 1 CMD_STRING ALIGNED STATIC,
        2 LEN UBIN BYTE CALIGNED INIT (LENGTHC(CMD_STRING.TEXT)),
        2 TEXT CALIGNED,
          3 * CHAR (5) INIT('EDIT ') CALIGNED,
          3 EDIT_FID CHAR (72) CALIGNED;
%VLP_ACCT (FPTN=EDIT_ACCT,
 ACCT=':SYS');
%FPT_LINK (FPTN=INTO_EDIT,
 ACCT=EDIT_ACCT,
 CMD=CMD_STRING,
 NAME=EDIT_NAME);
 
%FPT_READ(FPTN=READIN,
 DCB=M$SI,
 BUF=READBUF);
  DCL READBUF CHAR(%INBUFSIZE) CALIGNED STATIC;
  DCL M$SI DCB;
 
%FPT_WRITE(FPTN=WRITEOUT,
 DCB=M$LO,
 BUF=WRITEBUF,
 VFC=YES);
  DCL WRITEBUF CHAR(%IOBUFSIZE) CALIGNED STATIC;
  DCL M$LO DCB;
 
%FPT_WRITE(FPTN=WRITEDOC,
 DCB=M$OU,
 BUF=DOCBUF,
 KEY=EDITKEY,
 NEWKEY=YES,
 ONEWKEY=NO);
  DCL DOCBUF CHAR (%IOBUFSIZE) CALIGNED STATIC;
 
  DCL OUT_FILE_NAME CHAR (31) CALIGNED STATIC;
%FPT_UNFID (FPTN = GET_FILE_NAME,
 DCB = M$OU,
 TEXTFID = OUT_FILE_NAME);
 
%FPT_PRECORD (FPTN = FIND_END,
 DCB = M$OU,
 KEY = KEY_BUF,
 KEYR = YES,
 N = -1);
  DCL 1 KEY_BUF WALIGNED STATIC,
        2 SIZE SBIN BYTE CALIGNED INIT (3),
        2 KEY_VAL UBIN (27) UNAL ;
 
%FPT_PFIL (FPTN = END_OF_FILE,
 BOF = NO,
 DCB = M$OU);
 
 %FPT_TIME (FPTN=GET_DATE,
 DATE=DATEVAL,
 DEST=LOCAL);
  DCL DATEVAL CHAR (8) CALIGNED STATIC;
 
  DCL 1 EDITKEY WALIGNED STATIC,
        2 KEYSIZE UBIN BYTE CALIGNED INIT (3),
        2 COUNT UBIN (27) UNAL INIT (1000);
  DCL KEY_INCREMENT UBIN ALIGNED ;
  DCL TEMP UBIN ALIGNED;
 
%FPT_OPEN(FPTN=OPEN_OU,
 ACS=DIRECT,
 DCB=M$OU);
 
%FPT_OPEN( FPTN=OPEN_SI,
 DCB=M$SI);
 
%FPT_OPEN( FPTN=OPEN_LO,
 DCB=M$LO);
 
%M$DCB(DCBN=M$OU,
 CTG=YES,
 ORG=KEYED,
 NAME='*DOC',
 FUN=CREATE,
 ASN=FILE);
  DCL P_DCB$ PTR;
 
%FPT_SINPUT(FPTN=BAKTOUSER,
 BUF=REREADBUF);
  DCL REREADBUF CHAR (%IOBUFSIZE) CALIGNED STATIC;
 
%FPT_PROMPT(FPTN=PROMPTN,
 PROMPT=PROMTCARS);
  DCL PROMTCARS CHAR (20) CALIGNED STATIC;
 
%FPT_CLOSE( FPTN=CLOSE_LO,
 DCB=M$LO);
 
%FPT_CLOSE( FPTN=CLOSE_SI,
 DCB=M$SI);
 
%FPT_CLOSE( FPTN=CLOSE_OU,
 DCB=M$OU);
 
%FPT_ERRMSG( FPTN=MERR,
 BUF = BUPHER,
 OUTDCB1 = M$LO);
 
  DCL SLASH CHAR (0) CONSTANT INIT ('/');
  DCL EMM CHAR (0) CONSTANT INIT ('M');
  DCL STAR CHAR (0) CONSTANT INIT ('*');
  DCL PEE CHAR (0) CONSTANT INIT ('P');
  DCL EFF CHAR (0) CONSTANT INIT ('F');
  DCL AII CHAR (0) CONSTANT INIT ('I');
  DCL DEE CHAR (0) CONSTANT INIT ('D');
  DCL OOH CHAR (0) CONSTANT INIT ('O');
  DCL BEE CHAR (0) CONSTANT INIT ('B');
  DCL ENN CHAR (0) CONSTANT INIT ('N');
  DCL KAY CHAR (0) CONSTANT INIT ('K');
  DCL BLANK CHAR (0) CONSTANT INIT (' ');
  DCL NAME CHAR (0) CONSTANT INIT ('NAME: ');
  DCL MINUS CHAR (0) CONSTANT INIT (' - ');
  DCL DESC CHAR (0) CONSTANT INIT ('DESCRIPTION:');
  DCL PURP CHAR (0) CONSTANT INIT ('PURPOSE:');
  DCL REF CHAR (0) CONSTANT INIT ('REFERENCE:');
  DCL CAL CHAR (0) CONSTANT INIT ('CALL:');
  DCL DAT CHAR (0) CONSTANT INIT ('DATA:');
  DCL ENTR CHAR (0) CONSTANT INIT ('ENTRY:');
  DCL PARAMS CHAR (0) CONSTANT INIT ('PARAMETERS:');
  DCL INTFCE CHAR (0) CONSTANT INIT ('INTERFACE:');
  DCL ENVIRON CHAR (0) CONSTANT INIT ('ENVIRONMENT:');
  DCL INP CHAR (0) CONSTANT INIT ('INPUT:');
  DCL OUTP CHAR (0) CONSTANT INIT ('OUTPUT:');
  DCL SCR CHAR (0) CONSTANT INIT ('SCRATCH:');
  DCL MSG CHAR (0) CONSTANT INIT ('MESSAGE:');
  DCL ACTION CHAR (0) CONSTANT INIT ('ACTIONS:');
  DCL MEAN CHAR (0) CONSTANT INIT ('MEANING:');
  DCL KEYW CHAR (0) CONSTANT INIT ('KEYWORD:');
  DCL COM_FLD CHAR (80)CALIGNED STATIC;
 
  DCL DOCTYPE CHAR (1) CALIGNED ;
  DCL KEYRIGHT BIT (1) ALIGNED;
  DCL I UBIN;
  DCL LENTH UBIN;
  DCL RMARGIN UBIN ;
  DCL KEYSTART SBIN;
  DCL KEYSTARTSAVE UBIN;
  DCL LMARGINTEXT UBIN;
  DCL RMARGINDOC UBIN;
  DCL SNIDE BIT (1) ALIGNED;
  DCL M$SI$ PTR ALIGNED ;
 
%F$DCB;
%B$ALT;
%B$TCB;
  DCL B$TCB$ PTR SYMREF;
  DCL B$JIT$ PTR SYMREF ;
 
  SNIDE = SET;
  KEYRIGHT = NOTSET;
  KEY_INCREMENT = 1000;
  KEYSTARTSAVE = 5;
  LMARGINTEXT = 11;
  RMARGINDOC = 80;
  COM_FLD = '#DOCUMENTATION';
  HELP_DOC.PROCACCT_ = VECTOR (DCBADDR (DCBNUM (M$LM)) ->F$DCB.ACCT#);
  IF B$JIT.CCARS ~= B$JIT.CCDISP
    THEN DO;
      BUF.C = SUBSTR ( B$JIT.CCBUF,B$JIT.CCDISP);
      OPT_PCB.NCHARS = B$JIT.CCARS - B$JIT.CCDISP;
      CALL X$PARSE (OPT_PCB) ALTRET (ERR);
      NSUBLKS = OPT_PCB.OUT$-> OPT$OUT.NSUBLKS;
      DO I = 0 TO NSUBLKS-1;
          BLK$ = OPT_PCB.OUT$ -> OPT$OUT.SUBLK$(I);
          DO CASE (OPT$OUT.CODE);
             CASE (%$LEFT);
               CALL CHARBIN (LMARGINTEXT,OPT$SYM.TEXT);
             CASE (%$RIGHT);
               CALL CHARBIN (RMARGINDOC,OPT$SYM.TEXT);
             CASE (%$START);
               CALL BUILD_KEY (TEMP, OPT$OUT.SUBLK$(0) );
               EDITKEY.COUNT = TEMP;
             CASE (%$INCREMENT);
               CALL BUILD_KEY (KEY_INCREMENT, OPT$OUT.SUBLK$(0) );
             CASE (%$L_KEY);
               CALL CHARBIN (KEYSTARTSAVE,OPT$SYM.TEXT);
             CASE (%$R_KEY);
               CALL CHARBIN (KEYSTARTSAVE,OPT$SYM.TEXT);
               KEYRIGHT = SET;
             CASE (ELSE);
               GOTO ERR;
             END;
          END;
      END;
  LMARGINTEXT = LMARGINTEXT - 1;
  IF RMARGINDOC > %IOBUFSIZE
    THEN DO;
      RMARGIN = %IOBUFSIZE ;
      WRITEOUT.V.DVBYTE.VFC# = NOTSET;
      WRITEBUF = 'Right margin specified too large, using maximum of %IOBUFSIZE .';
      CALL M$WRITE (WRITEOUT) ALTRET (ERR);
      WRITEOUT.V.DVBYTE.VFC# = SET;
      END;
    ELSE DO;
      RMARGIN = RMARGINDOC ;
      END;
  IF LMARGINTEXT >= RMARGINDOC
    THEN DO;
      WRITEBUF = %CONCAT (%NOLINE,
          'Left margin greater than right margin, please start over.');
      CALL M$WRITE (WRITEOUT) ALTRET (ERR);
      RETURN;
      END;
  IF KEYRIGHT
    THEN DO;
      IF KEYSTARTSAVE >= RMARGINDOC
        THEN DO;
          WRITEBUF = %CONCAT (%NOLINE,
              'The right margin is too small to allow required text, please start over.');
          CALL M$WRITE (WRITEOUT) ALTRET (ERR);
          RETURN;
          END;
        ELSE DO;
          END;
      END;
    ELSE IF KEYSTARTSAVE + %LARGEST_KEY_LEN >= RMARGINDOC
        THEN DO;
          WRITEBUF = %CONCAT (%NOLINE,
              'The required text cannot fit between the keyword and right margins, start over.');
          CALL M$WRITE (WRITEOUT) ALTRET (ERR);
          RETURN;
          END;
  M$SI$ = DCBADDR(DCBNUM(M$SI));
  CALL M$OPEN(OPEN_OU) ALTRET (ERR);
  CALL M$OPEN (OPEN_SI) ALTRET (ERR);
  CALL M$OPEN (OPEN_LO) ALTRET (ERR);
  P_DCB$ = DCBADDR (DCBNUM(M$OU));
  IF P_DCB$->F$DCB.EXIST# = 2
    THEN DO;
      CALL GOTO_END;
      END;
  WRITEOUT.V.DVBYTE.VFC# = NOTSET;
  WRITEBUF =
      'EDICT HERE!  Type a "." for help with EDICT commands,';
  CALL M$WRITE (WRITEOUT) ALTRET (ERR);
  WRITEBUF =
      'or a "?" for help at what you are currently doing.';
  CALL M$WRITE (WRITEOUT) ALTRET (ERR);
 
  PROMTCARS = ' ';
  PROMPTN.PROMPT_ = VECTOR (SUBSTR (PROMTCARS,0,1));
  CALL M$PROMPT (PROMPTN) ALTRET (ERR);
  HELP_TOPIC = 'MENUHELP';
  HELP_LENGTH = 8;
  HELP_DOC.V.MORE# = '0'B;
  WRITEOUT.V.DVBYTE.VFC# = SET;
  DO UNTIL ('Y' = SUBSTR (READBUF,0,1) OR
      'N' = SUBSTR (READBUF,0,1) OR
      'y' = SUBSTR (READBUF,0,1) OR
      'n' = SUBSTR (READBUF,0,1) );
      WRITEBUF = %CONCAT(%NOLINE,
          'Do you want to create an M,P,F,I,O,B,K,N or D comment section? (Y/N)');
      CALL M$WRITE (WRITEOUT) ALTRET (ERR);
      READBUF = ' ';
      CALL M$READ (READIN) ALTRET (ERR);
      CALL TESTCHAR (READBUF);
      END; /* Do until                                                        */
  IF ('Y' = SUBSTR (READBUF,0,1) OR
      'y' = SUBSTR (READBUF,0,1) )
    THEN DO;
      SNIDE = NOTSET;
      DO UNTIL ('N' = SUBSTR (READBUF,0,1) OR
          'n' = SUBSTR (READBUF,0,1) );
          IF ('Y' = SUBSTR (READBUF,0,1) OR
              'y' = SUBSTR (READBUF,0,1) )
            THEN DO;
              HELP_TOPIC='MENU';
              HELP_LENGTH = 4;
              HELP_DOC.V.MORE# = '0'B;
              WRITEOUT.V.DVBYTE.VFC# = SET;
              DO UNTIL ('?' ~= SUBSTR (READBUF,0,1) AND
                  '.' ~= SUBSTR (READBUF,0,1) AND
                  '+' ~= SUBSTR (READBUF,0,1));
                  WRITEBUF = %CONCAT (%NOLINE,
                      'Enter M,P,F,I,O,B,K,N or D for which section you want to create: ');
                  CALL M$WRITE (WRITEOUT) ALTRET (ERR);
                  READBUF = ' ';
                  CALL M$READ (READIN) ALTRET (ERR);
                  CALL TESTCHAR (READBUF);
                  END;
              DO SELECT (SUBSTR(READBUF,0,1));
                 SELECT ('M','m');
                   CALL STARMSTAR;
                 SELECT ('P','p');
                   CALL STARPSTAR;
                 SELECT ('F','f');
                   CALL STARFSTAR;
                 SELECT ('I','i');
                   CALL STARISTAR;
                 SELECT ('D','d');
                   CALL STARDSTAR;
                 SELECT ('O','o');
                   CALL STAROSTAR;
                 SELECT ('B','b');
                   CALL STARBSTAR;
                 SELECT ('K','k');
                   CALL STARKSTAR;
                 SELECT ('N','n');
                   CALL STARNSTAR;
                 SELECT (ELSE);
                   WRITEOUT.V.DVBYTE.VFC# = NOTSET;
                   WRITEBUF =
                       'You are supposed to enter an M,P,F,I,O,B,K,N or D!!!';
                   CALL M$WRITE (WRITEOUT) ALTRET (ERR);
                   WRITEOUT.V.DVBYTE.VFC# = SET;
                 END; /* Do select                                            */
              END;
          PROMTCARS = ' ';
          PROMPTN.PROMPT_ = VECTOR( SUBSTR( PROMTCARS,0,1));
          CALL M$PROMPT (PROMPTN) ALTRET (ERR);
          HELP_TOPIC = 'MENUHELP';
          HELP_LENGTH = 8;
          HELP_DOC.V.MORE# = '0'B;
          WRITEBUF = %CONCAT(%NOLINE,
              'Do you want to create another M,P,F,I,O,B,K,N or D section? (Y/N)');
          CALL M$WRITE (WRITEOUT) ALTRET (ERR);
          READBUF = ' ';
          CALL M$READ (READIN) ALTRET (ERR);
          CALL TESTCHAR (READBUF);
          END;
      END;
 
  IF SNIDE = SET
    THEN DO;
      PROMPTN.PROMPT_ = VECTOR( SUBSTR( PROMTCARS,0,1));
      PROMTCARS = ' ';
      CALL M$PROMPT (PROMPTN) ALTRET (ERR);
      HELP_TOPIC = 'FILEQUES';
      HELP_LENGTH = 8;
      HELP_DOC.V.MORE# = '0'B;
      WRITEOUT.V.DVBYTE.VFC# = SET;
      DO UNTIL ('Y' = SUBSTR (READBUF,0,1) OR
          'N' = SUBSTR (READBUF,0,1) OR
          'y' = SUBSTR (READBUF,0,1) OR
          'n' = SUBSTR (READBUF,0,1) );
          WRITEBUF = %CONCAT(%NOLINE,
              'Do you want to document a file? (Y/N)  ');
          CALL M$WRITE (WRITEOUT) ALTRET (ERR);
          READBUF = ' ';
          CALL M$READ (READIN) ALTRET (ERR);
          CALL TESTCHAR (READBUF);
          END; /* Do until                                                    */
      IF ('Y' = SUBSTR(READBUF,0,1) OR
          'y' = SUBSTR(READBUF,0,1) )
        THEN DO;
          SNIDE = NOTSET;
          CALL STARMSTAR;
          CALL STARPSTAR;
          END ;
 
      PROMTCARS = ' ';
      PROMPTN.PROMPT_ = VECTOR (SUBSTR (PROMTCARS,0,1));
      CALL M$PROMPT (PROMPTN) ALTRET (ERR);
      HELP_TOPIC = 'MODQUES';
      HELP_LENGTH = 7;
      HELP_DOC.V.MORE# = '0'B;
      WRITEOUT.V.DVBYTE.VFC# = SET;
      DO UNTIL ('Y' = SUBSTR (READBUF,0,1) OR
          'N' = SUBSTR (READBUF,0,1) OR
          'y' = SUBSTR (READBUF,0,1) OR
          'n' = SUBSTR (READBUF,0,1) );
          WRITEBUF = %CONCAT(%NOLINE,
              'Do you want to document a module? (Y/N)  ');
          CALL M$WRITE(WRITEOUT) ALTRET (ERR);
          READBUF = ' ';
          CALL M$READ(READIN) ALTRET (ERR);
          CALL TESTCHAR (READBUF);
          END; /* Do until                                                    */
      IF ('Y' = SUBSTR (READBUF,0,1) OR
          'y' = SUBSTR (READBUF,0,1) )
        THEN DO;
          HELP_TOPIC='MODQUES';
          HELP_LENGTH = 7;
          HELP_DOC.V.MORE# = '0'B;
          DO UNTIL ('N' = SUBSTR (READBUF,0,1) OR
              'n' = SUBSTR (READBUF,0,1) );
              IF ('Y' = SUBSTR (READBUF,0,1) OR
                  'y' = SUBSTR (READBUF,0,1) )
                THEN DO;
                  SNIDE = NOTSET;
                  CALL STARFSTAR;
                  CALL STARDSTAR;
                  HELP_TOPIC = 'MODQUES';
                  HELP_LENGTH = 7;
                  HELP_DOC.V.MORE# = '0'B;
                  END;
              PROMTCARS = ' ';
              PROMPTN.PROMPT_ = VECTOR (SUBSTR (PROMTCARS,0,1));
              CALL M$PROMPT (PROMPTN) ALTRET (ERR);
              WRITEBUF = %CONCAT(%NOLINE,
                  'Do you want to document another module? (Y/N)  ');
              CALL M$WRITE (WRITEOUT) ALTRET (ERR);
              READBUF = ' ';
              CALL M$READ (READIN) ALTRET (ERR);
              CALL TESTCHAR (READBUF);
              END;
          END;
 
      PROMTCARS = ' ';
      PROMPTN.PROMPT_ = VECTOR (SUBSTR (PROMTCARS,0,1));
      CALL M$PROMPT (PROMPTN) ALTRET (ERR);
      HELP_TOPIC = 'INTMODQUES';
      HELP_LENGTH = 10;
      HELP_DOC.V.MORE# = '0'B;
      WRITEOUT.V.DVBYTE.VFC# = SET;
      DO UNTIL ('Y' = SUBSTR (READBUF,0,1) OR
          'N' = SUBSTR (READBUF,0,1) OR
          'y' = SUBSTR (READBUF,0,1) OR
          'n' = SUBSTR (READBUF,0,1) );
          WRITEBUF = %CONCAT(%NOLINE,
              'Do you want to document an internal module? (Y/N)');
          CALL M$WRITE (WRITEOUT) ALTRET (ERR);
          READBUF = ' ';
          CALL M$READ (READIN) ALTRET (ERR);
          CALL TESTCHAR (READBUF);
          END; /* Do until                                                    */
      IF ('Y' = SUBSTR (READBUF,0,1) OR
          'y' = SUBSTR (READBUF,0,1) )
        THEN DO;
          HELP_TOPIC='DEFS';
          HELP_LENGTH = 4;
          HELP_DOC.V.MORE# = '0'B;
          DO UNTIL ('N' = SUBSTR (READBUF,0,1) OR
              'n' = SUBSTR (READBUF,0,1) );
              IF ('Y' = SUBSTR (READBUF,0,1) OR
                  'y' = SUBSTR (READBUF,0,1) )
                THEN DO;
                  SNIDE = NOTSET;
                  CALL STARISTAR;
                  HELP_TOPIC = 'INTMODQUES';
                  HELP_LENGTH = 10;
                  HELP_DOC.V.MORE# = '0'B;
                  END;
              PROMTCARS = ' ';
              PROMPTN.PROMPT_ = VECTOR( SUBSTR( PROMTCARS,0,1));
              CALL M$PROMPT (PROMPTN) ALTRET (ERR);
              WRITEBUF = %CONCAT(%NOLINE,
                  'Do you want to document another internal module? (Y/N)');
              CALL M$WRITE (WRITEOUT) ALTRET (ERR);
              READBUF = ' ';
              CALL M$READ (READIN) ALTRET (ERR);
              CALL TESTCHAR (READBUF);
              END;
          END;
      END;
 
  IF SNIDE
    THEN DO;
      WRITEBUF = %CONCAT(%NOLINE,
          'WHAT DO YOU WANT FROM ME?????????? ');
      CALL M$WRITE (WRITEOUT) ALTRET (ERR);
      END; /* Of main                                                         */
 
TESTCHAR: PROC (READBUF);
  DCL READBUF CHAR (%INBUFSIZE) ;
  DCL TEMP_MORE BIT (1);
  DCL TEMP_LEN UBIN;
  DCL TEMP_TOPIC CHAR (30) CALIGNED;
  WRITEOUT.V.DVBYTE.VFC# = NOTSET ;
  IF '. ' = SUBSTR (READBUF,0,2)
    THEN DO;
      CALL DOT_HELP;
      END;
    ELSE
      IF '?' = SUBSTR(READBUF,0,1)
        THEN DO;
          KEY1.L# = HELP_LENGTH;
          KEY1.NAME# = HELP_TOPIC;
          CALL M$HELP (HELP_DOC) ALTRET (ERR);
          HELP_DOC.V.MORE# = '1'B;
          END ;
        ELSE
          IF '+' = SUBSTR(READBUF,0,1)
            THEN DO;
              CALL BUILD_PLUS;
              END;
            ELSE
              IF ('.C' = SUBSTR (READBUF,0,2) OR
                  '.c' = SUBSTR (READBUF,0,2) )
                THEN DO;
                  CALL RESET_COMMENT;
                  END;
                ELSE
                  IF ('.E' = SUBSTR (READBUF,0,2) OR
                      '.e' = SUBSTR (READBUF,0,2) )
                    THEN DO;
                      CALL EDITFILE;
                      END;
                    ELSE
                      IF ('.I' = SUBSTR(READBUF,0,2) OR
                          '.i' = SUBSTR(READBUF,0,2) )
                        THEN DO;
                          CALL RESET_INCREMENT;
                          END;
                        ELSE
                          IF ('.S' = SUBSTR(READBUF,0,2) OR
                              '.s' = SUBSTR(READBUF,0,2) )
                            THEN DO;
                              CALL RESET_START;
                              END;
  WRITEOUT.V.DVBYTE.VFC# = SET ;
  RETURN;
ERR: ;
  IF B$TCB$->B$TCB.ALT$->B$ALT.ERR.CODE = %E$NOMOREHELP
    THEN DO;
      MERR.V.INCLCODE# = '0'B;
      END;
    ELSE DO;
      MERR.V.INCLCODE# = '1'B;
      END;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
  WRITEOUT.V.DVBYTE.VFC# = SET ;
END TESTCHAR;
 
STARMSTAR: PROC;
  DCL STSLSH CHAR (3) CONSTANT INIT (' */');
  DCL NAMESAVE CHAR (30) STATIC ;
  DCL STARM CHAR (5) CONSTANT INIT ('/*M* ');
  DCL NAMELEN UBIN ;
  DCL DESCLEN UBIN ;
  DOCTYPE = EMM;
  CALL SET_PROMPT (NAME,LENGTHC(NAME)) ;
  HELP_TOPIC = 'MNAME';
  HELP_LENGTH = 5;
  HELP_DOC.V.MORE# = '0'B;
  DO UNTIL ('?' ~= SUBSTR (READBUF,0,1) AND
      '+' ~= SUBSTR (READBUF,0,1) AND
      '.' ~= SUBSTR (READBUF,0,1));
      READBUF = ' ';
      CALL M$READ (READIN) ALTRET (ERR);
      CALL TESTCHAR (READBUF);
      END;
  NAMELEN = M$SI$->F$DCB.ARS# ;
  DO WHILE (NAMELEN = 0);
      READBUF = 'No name,';
      NAMELEN = 8;
      END;
  DO WHILE ( NAMELEN > 30 );
      WRITEOUT.V.DVBYTE.VFC# = NOTSET ;
      WRITEBUF = '  Name length limit is 30 characters. Retry.';
      CALL M$WRITE (WRITEOUT) ALTRET (ERR);
      WRITEOUT.V.DVBYTE.VFC# = SET ;
      REREADBUF = READBUF;
      READIN.V.DVBYTE.REREAD# = SET;
      BAKTOUSER.BUF_ = VECTOR( SUBSTR( READBUF,0,NAMELEN));
      CALL M$SINPUT (BAKTOUSER) ALTRET (ERR);
      CALL M$READ (READIN) ALTRET (ERR);
      NAMELEN = M$SI$->F$DCB.ARS#;
      READIN.V.DVBYTE.REREAD# = NOTSET;
      END;
  NAMESAVE = READBUF;
  CALL SET_PROMPT (DESC,LENGTHC(DESC));
  HELP_TOPIC = 'MDESCRIPTION';
  HELP_LENGTH = 12;
  HELP_DOC.V.MORE# = '0'B;
  DO UNTIL ('?' ~= SUBSTR (READBUF,0,1) AND
      '+' ~= SUBSTR (READBUF,0,1) AND
      '.' ~= SUBSTR (READBUF,0,1));
      READBUF = ' ';
      CALL M$READ (READIN) ALTRET (ERR);
      CALL TESTCHAR (READBUF);
      END;
  DESCLEN = M$SI$->F$DCB.ARS# ;
  DO WHILE (DESCLEN = 0);
      READBUF = 'No description.';
      DESCLEN = 15;
      END;
  DO WHILE (DESCLEN > RMARGIN - (NAMELEN + SIZEC (STARM) +
      SIZEC (MINUS) + SIZEC (STSLSH)));
      WRITEOUT.V.DVBYTE.VFC# = NOTSET ;
      WRITEBUF = '  Desc length too long. Please retype.';
      CALL M$WRITE (WRITEOUT) ALTRET (ERR);
      WRITEOUT.V.DVBYTE.VFC# = SET ;
      REREADBUF = READBUF;
      READIN.V.DVBYTE.REREAD# = SET;
      BAKTOUSER.BUF_ = VECTOR( SUBSTR( READBUF,0,DESCLEN));
      CALL M$SINPUT (BAKTOUSER) ALTRET (ERR);
      CALL M$READ (READIN) ALTRET (ERR);
      DESCLEN = M$SI$->F$DCB.ARS#;
      READIN.V.DVBYTE.REREAD# = NOTSET;
      END;
  CALL CONCAT (DOCBUF,STARM,SUBSTR(NAMESAVE,0,NAMELEN),
      MINUS,SUBSTR(READBUF,0,DESCLEN),STSLSH);
  CALL WRITE ;
  RETURN;
ERR: ;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
END STARMSTAR ;
 
STARPSTAR: PROC;
  DOCTYPE = PEE ;
  CALL SETHEAD;
  CALL DOTEXT (PURP,REQUIRED);
  CALL DOTEXT (DESC,REQUIRED);
  CALL DOTEXT (REF);
  CALL SETEND;
END STARPSTAR;
 
STARFSTAR: PROC;
  DOCTYPE = EFF;
  CALL SETHEAD;
  CALL DOTEXT (PURP,REQUIRED);
  CALL DOTEXT (DESC,REQUIRED);
  CALL DOTEXT (REF);
  CALL SETEND;
END STARFSTAR;
 
STARDSTAR:PROC;
  DOCTYPE = DEE;
  CALL SETHEAD;
  CALL DOTEXT (ENTR);
  CALL DOTEXT (CAL,REQUIRED);
  CALL DOTEXT (PARAMS);
  CALL DOTEXT (INTFCE);
  CALL DOTEXT (ENVIRON,REQUIRED);
  CALL DOTEXT (INP,REQUIRED);
  CALL DOTEXT (OUTP,REQUIRED);
  CALL DOTEXT(SCR,REQUIRED);
  CALL DOTEXT (DESC,REQUIRED);
  CALL SETEND;
END STARDSTAR;
 
STARISTAR: PROC;
  DOCTYPE = AII;
  CALL SETHEAD;
  CALL DOTEXT (PURP,REQUIRED);
  CALL DOTEXT (CAL,REQUIRED);
  CALL DOTEXT (PARAMS);
  CALL DOTEXT (DAT,REQUIRED);
  CALL DOTEXT (DESC,REQUIRED);
  CALL SETEND;
END STARISTAR;
 
STAROSTAR: PROC;
  DOCTYPE = OOH;
  DOCBUF = ' ';
  CALL CONCAT (DOCBUF,SLASH,STAR,OOH,STAR);
  CALL WRITE;
  CALL DOTEXT (MSG,REQUIRED);
  CALL DOTEXT (ACTION,REQUIRED);
  CALL DOTEXT (MEAN);
  CALL SETEND;
END STAROSTAR;
 
STARBSTAR: PROC ;
  DCL STARB CHAR (5) CONSTANT INIT ('/*B* ');
  DCL NAMESAVE CHAR (30) STATIC;
  DCL NAMELEN UBIN;
  DCL DESCLEN UBIN;
  DCL LINELEN UBIN;
  DCL LINESIZE UBIN;
  DCL BLANKPOS UBIN;
  DCL START UBIN;
  DCL INPUTSIZE UBIN;
  DOCTYPE = BEE;
  CALL SET_PROMPT (NAME,LENGTHC(NAME)) ;
  HELP_TOPIC = 'BNAME';
  HELP_LENGTH = 5;
  HELP_DOC.V.MORE# = '0'B;
  NAMELEN = 0;
  LINELEN = RMARGIN - KEYSTARTSAVE;
  DO UNTIL ('?' ~= SUBSTR (READBUF,0,1) AND
      '+' ~= SUBSTR (READBUF,0,1) AND
      '.' ~= SUBSTR (READBUF,0,1) AND
      NAMELEN ~= 0);
      READBUF = ' ';
      CALL M$READ (READIN) ALTRET (ERR);
      CALL TESTCHAR (READBUF);
      NAMELEN = M$SI$->F$DCB.ARS# ;
      IF (NAMELEN = 0)
        THEN DO;
          WRITEOUT.V.DVBYTE.VFC# = NOTSET ;
          WRITEBUF = '  You must input a name.';
          CALL M$WRITE (WRITEOUT) ALTRET (ERR);
          WRITEOUT.V.DVBYTE.VFC# = SET ;
          END;
      END;
  IF (( NAMELEN > 30 ) OR
      (NAMELEN > LINELEN - (SIZEC(STARB) + SIZEC(MINUS))))
    THEN DO;
      WRITEOUT.V.DVBYTE.VFC# = NOTSET ;
      WRITEBUF = ' WARNING: Name is exceeding line or name length limits.';
      CALL M$WRITE (WRITEOUT) ALTRET (ERR);
      WRITEOUT.V.DVBYTE.VFC# = SET ;
      REREADBUF = READBUF;
      READIN.V.DVBYTE.REREAD# = SET;
      BAKTOUSER.BUF_ = VECTOR( SUBSTR( READBUF,0,NAMELEN));
      CALL M$SINPUT (BAKTOUSER) ALTRET (ERR);
      CALL M$READ (READIN) ALTRET (ERR);
      NAMELEN = M$SI$->F$DCB.ARS#;
      READIN.V.DVBYTE.REREAD# = NOTSET;
      END;
  NAMESAVE = READBUF;
  CALL SET_PROMPT (DESC,LENGTHC(DESC));
  HELP_TOPIC = 'BDESCRIPTION';
  HELP_LENGTH = 12;
  HELP_DOC.V.MORE# = '0'B;
  DESCLEN = 0;
  DO UNTIL ('?' ~= SUBSTR (READBUF,0,1) AND
      '+' ~= SUBSTR (READBUF,0,1) AND
      '.' ~= SUBSTR (READBUF,0,1) AND
      DESCLEN ~= 0 );
      READBUF = ' ';
      CALL M$READ (READIN) ALTRET (ERR);
      CALL TESTCHAR (READBUF);
      DESCLEN = M$SI$->F$DCB.ARS# ;
      IF (DESCLEN = 0)
        THEN DO;
          WRITEOUT.V.DVBYTE.VFC# = NOTSET ;
          WRITEBUF = ' You must input a description.';
          CALL M$WRITE (WRITEOUT) ALTRET (ERR);
          WRITEOUT.V.DVBYTE.VFC# = SET ;
          END;
      END;
  LINESIZE = RMARGIN - (SIZEC(STARB) + NAMELEN + SIZEC(MINUS));
  IF (LINELEN < (SIZEC(STARB) + NAMELEN + SIZEC(MINUS)))
    THEN DO;
      CALL CONCAT (DOCBUF,STARB,SUBSTR(NAMESAVE,0,NAMELEN),MINUS);
      CALL WRITE;
      LINESIZE = LINELEN;
      NAMELEN = 0;
      END;
  START = 0;
  IF (NAMELEN ~= 0)
    THEN DO;
      IF DESCLEN >= LINESIZE
        THEN DO;
          CALL INDEX1R (BLANKPOS,' ',SUBSTR(READBUF,START,LINESIZE)) ALTRET (NO_BLANK1);
          DOCBUF = ' ';
          CALL CONCAT (DOCBUF,STARB,SUBSTR(NAMESAVE,0,NAMELEN),MINUS,SUBSTR(READBUF,0,BLANKPOS));
          CALL WRITE;
          START = START + BLANKPOS + 1;
          GOTO ENDLONGLINE;
NO_BLANK1: ;
          DOCBUF = ' ';
          CALL CONCAT (DOCBUF,STARB,SUBSTR(NAMESAVE,0,NAMELEN),MINUS,SUBSTR(READBUF,0,LINESIZE));
          CALL WRITE;
          START = START + LINESIZE;
ENDLONGLINE: ;
          LINELEN = RMARGIN - LMARGINTEXT;
          DO WHILE (DESCLEN - START >= LINELEN);
              CALL INDEX1R (BLANKPOS,' ',SUBSTR (READBUF,START,LINELEN)) ALTRET (NO_BLANK);
              DOCBUF = ' ';
              CALL INSERT (DOCBUF,LMARGINTEXT,,
                  SUBSTR(READBUF,START,BLANKPOS)) ALTRET (ERR);
              CALL WRITE;
              START = START + BLANKPOS + 1;
              GOTO ENDO ;
NO_BLANK :    ;
              DOCBUF = ' ';
              CALL INSERT (DOCBUF,LMARGINTEXT,,
                  SUBSTR (READBUF,START,LINELEN)) ALTRET (ERR);
              CALL WRITE;
              START = START + LINELEN;
ENDO:         END; /* Do while                                                */
          IF START < DESCLEN
            THEN DO;
              READIN.V.DVBYTE.REREAD# = SET ;
              REREADBUF = SUBSTR (READBUF,START,(DESCLEN - START));
              BAKTOUSER.BUF_ = VECTOR (SUBSTR (READBUF,START,(DESCLEN - START)));
              CALL M$SINPUT (BAKTOUSER) ALTRET (ERR);
              READBUF = ' ';
              CALL M$READ (READIN) ALTRET (ERR);
              READIN.V.DVBYTE.REREAD# = NOTSET;
              CALL TESTCHAR (READBUF);
              END;
            ELSE DO;
              END;
          END;
        ELSE DO;
          DOCBUF = ' ';
          CALL CONCAT (DOCBUF,STARB,SUBSTR(NAMESAVE,0,NAMELEN),MINUS,SUBSTR(READBUF,0,DESCLEN));
          CALL WRITE;
          READBUF = ' ';
          CALL M$READ (READIN) ALTRET (ERR);
          CALL TESTCHAR (READBUF);
          START = DESCLEN;
          END;
      END;
  INPUTSIZE = M$SI$->F$DCB.ARS# ;
  DO WHILE (INPUTSIZE > 0);
      IF '.' ~= SUBSTR (READBUF,0,1) AND
          '+' ~= SUBSTR (READBUF,0,1) AND
          '?' ~= SUBSTR (READBUF,0,1)
        THEN DO;
          CALL SETEXT (INPUTSIZE,LINELEN);
          END;
      READBUF = ' ';
      CALL M$READ (READIN) ALTRET (ERR);
      CALL TESTCHAR (READBUF);
      INPUTSIZE = M$SI$->F$DCB.ARS# ;
      END;
  CALL SETEND;
  RETURN;
ERR: ;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
END STARBSTAR;
 
STARKSTAR: PROC ;
  DCL STARK CHAR (5) CONSTANT INIT ('/*K* ');
  DCL NAMESAVE CHAR (30) STATIC;
  DCL NAMELEN UBIN;
  DCL DESCLEN UBIN;
  DCL LINELEN UBIN;
  DCL LINESIZE UBIN;
  DCL BLANKPOS UBIN;
  DCL START UBIN;
  DCL INPUTSIZE UBIN;
  DOCTYPE = KAY;
  CALL SET_PROMPT (NAME,LENGTHC(NAME)) ;
  HELP_TOPIC = 'KNAME';
  HELP_LENGTH = 5;
  HELP_DOC.V.MORE# = '0'B;
  NAMELEN = 0;
  LINELEN = RMARGIN - KEYSTARTSAVE;
  DO UNTIL ('?' ~= SUBSTR (READBUF,0,1) AND
      '+' ~= SUBSTR (READBUF,0,1) AND
      '.' ~= SUBSTR (READBUF,0,1) AND
      NAMELEN ~= 0);
      READBUF = ' ';
      CALL M$READ (READIN) ALTRET (ERR);
      CALL TESTCHAR (READBUF);
      NAMELEN = M$SI$->F$DCB.ARS# ;
      IF (NAMELEN = 0)
        THEN DO;
          WRITEOUT.V.DVBYTE.VFC# = NOTSET ;
          WRITEBUF = '  You must input a name.';
          CALL M$WRITE (WRITEOUT) ALTRET (ERR);
          WRITEOUT.V.DVBYTE.VFC# = SET ;
          END;
      END;
  IF (( NAMELEN > 30 ) OR
      (NAMELEN > LINELEN - (SIZEC(STARK) + SIZEC(MINUS))))
    THEN DO;
      WRITEOUT.V.DVBYTE.VFC# = NOTSET ;
      WRITEBUF = ' WARNING: Name is exceeding line or name length limits.';
      CALL M$WRITE (WRITEOUT) ALTRET (ERR);
      WRITEOUT.V.DVBYTE.VFC# = SET ;
      REREADBUF = READBUF;
      READIN.V.DVBYTE.REREAD# = SET;
      BAKTOUSER.BUF_ = VECTOR( SUBSTR( READBUF,0,NAMELEN));
      CALL M$SINPUT (BAKTOUSER) ALTRET (ERR);
      CALL M$READ (READIN) ALTRET (ERR);
      NAMELEN = M$SI$->F$DCB.ARS#;
      READIN.V.DVBYTE.REREAD# = NOTSET;
      END;
  NAMESAVE = READBUF;
  CALL SET_PROMPT (DESC,LENGTHC(DESC));
  HELP_TOPIC = 'KDESCRIPTION';
  HELP_LENGTH = 12;
  HELP_DOC.V.MORE# = '0'B;
  DESCLEN = 0;
  DO UNTIL ('?' ~= SUBSTR (READBUF,0,1) AND
      '+' ~= SUBSTR (READBUF,0,1) AND
      '.' ~= SUBSTR (READBUF,0,1) AND
      DESCLEN ~= 0 );
      READBUF = ' ';
      CALL M$READ (READIN) ALTRET (ERR);
      CALL TESTCHAR (READBUF);
      DESCLEN = M$SI$->F$DCB.ARS# ;
      IF (DESCLEN = 0)
        THEN DO;
          WRITEOUT.V.DVBYTE.VFC# = NOTSET ;
          WRITEBUF = ' You must input a description.';
          CALL M$WRITE (WRITEOUT) ALTRET (ERR);
          WRITEOUT.V.DVBYTE.VFC# = SET ;
          END;
      END;
  LINESIZE = RMARGIN - (SIZEC(STARK) + NAMELEN + SIZEC(MINUS));
  IF (LINELEN < (SIZEC(STARK) + NAMELEN + SIZEC(MINUS)))
    THEN DO;
      CALL CONCAT (DOCBUF,STARK,SUBSTR(NAMESAVE,0,NAMELEN),MINUS);
      CALL WRITE;
      LINESIZE = LINELEN;
      NAMELEN = 0;
      END;
  START = 0;
  IF (NAMELEN ~= 0)
    THEN DO;
      IF DESCLEN >= LINESIZE
        THEN DO;
          CALL INDEX1R (BLANKPOS,' ',SUBSTR(READBUF,START,LINESIZE)) ALTRET (NO_BLANK1);
          DOCBUF = ' ';
          CALL CONCAT (DOCBUF,STARK,SUBSTR(NAMESAVE,0,NAMELEN),MINUS,SUBSTR(READBUF,0,BLANKPOS));
          CALL WRITE;
          START = START + BLANKPOS + 1;
          GOTO ENDLONGLINE;
NO_BLANK1: ;
          DOCBUF = ' ';
          CALL CONCAT (DOCBUF,STARK,SUBSTR(NAMESAVE,0,NAMELEN),MINUS,SUBSTR(READBUF,0,LINESIZE));
          CALL WRITE;
          START = START + LINESIZE;
ENDLONGLINE: ;
          LINELEN = RMARGIN - LMARGINTEXT;
          DO WHILE (DESCLEN - START >= LINELEN);
              CALL INDEX1R (BLANKPOS,' ',SUBSTR (READBUF,START,LINELEN)) ALTRET (NO_BLANK);
              DOCBUF = ' ';
              CALL INSERT (DOCBUF,LMARGINTEXT,,
                  SUBSTR(READBUF,START,BLANKPOS)) ALTRET (ERR);
              CALL WRITE;
              START = START + BLANKPOS + 1;
              GOTO ENDO ;
NO_BLANK :    ;
              DOCBUF = ' ';
              CALL INSERT (DOCBUF,LMARGINTEXT,,
                  SUBSTR (READBUF,START,LINELEN)) ALTRET (ERR);
              CALL WRITE;
              START = START + LINELEN;
ENDO:         END; /* Do while                                                */
          IF START < DESCLEN
            THEN DO;
              READIN.V.DVBYTE.REREAD# = SET ;
              REREADBUF = SUBSTR (READBUF,START,(DESCLEN - START));
              BAKTOUSER.BUF_ = VECTOR (SUBSTR (READBUF,START,(DESCLEN - START)));
              CALL M$SINPUT (BAKTOUSER) ALTRET (ERR);
              READBUF = ' ';
              CALL M$READ (READIN) ALTRET (ERR);
              READIN.V.DVBYTE.REREAD# = NOTSET;
              CALL TESTCHAR (READBUF);
              END;
            ELSE DO;
              END;
          END;
        ELSE DO;
          DOCBUF = ' ';
          CALL CONCAT (DOCBUF,STARK,SUBSTR(NAMESAVE,0,NAMELEN),MINUS,SUBSTR(READBUF,0,DESCLEN));
          CALL WRITE;
          READBUF = ' ';
          CALL M$READ (READIN) ALTRET (ERR);
          CALL TESTCHAR (READBUF);
          START = DESCLEN;
          END;
      END;
  INPUTSIZE = M$SI$->F$DCB.ARS# ;
  DO WHILE (INPUTSIZE > 0);
      IF '.' ~= SUBSTR (READBUF,0,1) AND
          '+' ~= SUBSTR (READBUF,0,1) AND
          '?' ~= SUBSTR (READBUF,0,1)
        THEN DO;
          CALL SETEXT (INPUTSIZE,LINELEN);
          END;
      READBUF = ' ';
      CALL M$READ (READIN) ALTRET (ERR);
      CALL TESTCHAR (READBUF);
      INPUTSIZE = M$SI$->F$DCB.ARS# ;
      END;
  CALL SETEND;
  RETURN;
ERR: ;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
END STARKSTAR;
 
STARNSTAR: PROC ;
  DCL STARN CHAR (5) CONSTANT INIT ('/*N* ');
  DCL NAMESAVE CHAR (30) STATIC;
  DCL NAMELEN UBIN;
  DCL DESCLEN UBIN;
  DCL LINELEN UBIN;
  DCL LINESIZE UBIN;
  DCL BLANKPOS UBIN;
  DCL START UBIN;
  DCL INPUTSIZE UBIN;
  DOCTYPE = ENN;
  CALL SET_PROMPT (KEYW,LENGTHC(KEYW)) ;
  HELP_TOPIC = 'NKEYW';
  HELP_LENGTH = 5;
  HELP_DOC.V.MORE# = '0'B;
  NAMELEN = 0;
  LINELEN = RMARGIN - KEYSTARTSAVE;
  DO UNTIL ('?' ~= SUBSTR (READBUF,0,1) AND
      '+' ~= SUBSTR (READBUF,0,1) AND
      '.' ~= SUBSTR (READBUF,0,1) AND
      NAMELEN ~= 0);
      READBUF = ' ';
      CALL M$READ (READIN) ALTRET (ERR);
      CALL TESTCHAR (READBUF);
      NAMELEN = M$SI$->F$DCB.ARS# ;
      IF (NAMELEN = 0)
        THEN DO;
          WRITEOUT.V.DVBYTE.VFC# = NOTSET ;
          WRITEBUF = '  You must input a name.';
          CALL M$WRITE (WRITEOUT) ALTRET (ERR);
          WRITEOUT.V.DVBYTE.VFC# = SET ;
          END;
      END;
  IF (( NAMELEN > 30 ) OR
      (NAMELEN > LINELEN - (SIZEC(STARN) + SIZEC(MINUS))))
    THEN DO;
      WRITEOUT.V.DVBYTE.VFC# = NOTSET ;
      WRITEBUF = ' WARNING: Name is exceeding line or name length limits.';
      CALL M$WRITE (WRITEOUT) ALTRET (ERR);
      WRITEOUT.V.DVBYTE.VFC# = SET ;
      REREADBUF = READBUF;
      READIN.V.DVBYTE.REREAD# = SET;
      BAKTOUSER.BUF_ = VECTOR( SUBSTR( READBUF,0,NAMELEN));
      CALL M$SINPUT (BAKTOUSER) ALTRET (ERR);
      CALL M$READ (READIN) ALTRET (ERR);
      NAMELEN = M$SI$->F$DCB.ARS#;
      READIN.V.DVBYTE.REREAD# = NOTSET;
      END;
  NAMESAVE = READBUF;
  CALL SET_PROMPT (DESC,LENGTHC(DESC));
  HELP_TOPIC = 'NDESCRIPTION';
  HELP_LENGTH = 12;
  HELP_DOC.V.MORE# = '0'B;
  DESCLEN = 0;
  DO UNTIL ('?' ~= SUBSTR (READBUF,0,1) AND
      '+' ~= SUBSTR (READBUF,0,1) AND
      '.' ~= SUBSTR (READBUF,0,1) AND
      DESCLEN ~= 0 );
      READBUF = ' ';
      CALL M$READ (READIN) ALTRET (ERR);
      CALL TESTCHAR (READBUF);
      DESCLEN = M$SI$->F$DCB.ARS# ;
      IF (DESCLEN = 0)
        THEN DO;
          WRITEOUT.V.DVBYTE.VFC# = NOTSET ;
          WRITEBUF = ' You must input a description.';
          CALL M$WRITE (WRITEOUT) ALTRET (ERR);
          WRITEOUT.V.DVBYTE.VFC# = SET ;
          END;
      END;
  LINESIZE = RMARGIN - (SIZEC(STARN) + NAMELEN + SIZEC(MINUS));
  IF (LINELEN < (SIZEC(STARN) + NAMELEN + SIZEC(MINUS)))
    THEN DO;
      CALL CONCAT (DOCBUF,STARN,SUBSTR(NAMESAVE,0,NAMELEN),MINUS);
      CALL WRITE;
      LINESIZE = LINELEN;
      NAMELEN = 0;
      END;
  START = 0;
  IF (NAMELEN ~= 0)
    THEN DO;
      IF DESCLEN >= LINESIZE
        THEN DO;
          CALL INDEX1R (BLANKPOS,' ',SUBSTR(READBUF,START,LINESIZE)) ALTRET (NO_BLANK1);
          DOCBUF = ' ';
          CALL CONCAT (DOCBUF,STARN,SUBSTR(NAMESAVE,0,NAMELEN),MINUS,SUBSTR(READBUF,0,BLANKPOS));
          CALL WRITE;
          START = START + BLANKPOS + 1;
          GOTO ENDLONGLINE;
NO_BLANK1: ;
          DOCBUF = ' ';
          CALL CONCAT (DOCBUF,STARN,SUBSTR(NAMESAVE,0,NAMELEN),MINUS,SUBSTR(READBUF,0,LINESIZE));
          CALL WRITE;
          START = START + LINESIZE;
ENDLONGLINE: ;
          LINELEN = RMARGIN - LMARGINTEXT;
          DO WHILE (DESCLEN - START >= LINELEN);
              CALL INDEX1R (BLANKPOS,' ',SUBSTR (READBUF,START,LINELEN)) ALTRET (NO_BLANK);
              DOCBUF = ' ';
              CALL INSERT (DOCBUF,LMARGINTEXT,,
                  SUBSTR(READBUF,START,BLANKPOS)) ALTRET (ERR);
              CALL WRITE;
              START = START + BLANKPOS + 1;
              GOTO ENDO ;
NO_BLANK :    ;
              DOCBUF = ' ';
              CALL INSERT (DOCBUF,LMARGINTEXT,,
                  SUBSTR (READBUF,START,LINELEN)) ALTRET (ERR);
              CALL WRITE;
              START = START + LINELEN;
ENDO:         END; /* Do while                                                */
          IF START < DESCLEN
            THEN DO;
              READIN.V.DVBYTE.REREAD# = SET ;
              REREADBUF = SUBSTR (READBUF,START,(DESCLEN - START));
              BAKTOUSER.BUF_ = VECTOR (SUBSTR (READBUF,START,(DESCLEN - START)));
              CALL M$SINPUT (BAKTOUSER) ALTRET (ERR);
              READBUF = ' ';
              CALL M$READ (READIN) ALTRET (ERR);
              READIN.V.DVBYTE.REREAD# = NOTSET;
              CALL TESTCHAR (READBUF);
              END;
            ELSE DO;
              END;
          END;
        ELSE DO;
          DOCBUF = ' ';
          CALL CONCAT (DOCBUF,STARN,SUBSTR(NAMESAVE,0,NAMELEN),MINUS,SUBSTR(READBUF,0,DESCLEN));
          CALL WRITE;
          READBUF = ' ';
          CALL M$READ (READIN) ALTRET (ERR);
          CALL TESTCHAR (READBUF);
          START = DESCLEN;
          END;
      END;
  INPUTSIZE = M$SI$->F$DCB.ARS# ;
  DO WHILE (INPUTSIZE > 0);
      IF '.' ~= SUBSTR (READBUF,0,1) AND
          '+' ~= SUBSTR (READBUF,0,1) AND
          '?' ~= SUBSTR (READBUF,0,1)
        THEN DO;
          CALL SETEXT (INPUTSIZE,LINELEN);
          END;
      READBUF = ' ';
      CALL M$READ (READIN) ALTRET (ERR);
      CALL TESTCHAR (READBUF);
      INPUTSIZE = M$SI$->F$DCB.ARS# ;
      END;
  CALL SETEND;
  RETURN;
ERR: ;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
END STARNSTAR;
 
SETHEAD: PROC ;
  CALL SET_PROMPT (NAME,LENGTHC(NAME));
  DOCBUF = ' ';
  CALL CONCAT (DOCBUF,SLASH,STAR,DOCTYPE,STAR);
  CALL WRITE ;
  CALL CONCAT (HELP_TOPIC,DOCTYPE,SUBSTR(NAME,0,4));
  HELP_LENGTH = 5 ;
  HELP_DOC.V.MORE# = '0'B;
  IF KEYRIGHT
    THEN DO;
      KEYSTART = KEYSTARTSAVE - LENGTHC (NAME) + 1;
      END;
    ELSE DO;
      KEYSTART = KEYSTARTSAVE;
      END;
  IF KEYSTART < 0
    THEN DO;
      KEYSTART = 0;
      END;
  DO UNTIL ('?' ~= SUBSTR (READBUF,0,1) AND
      '+' ~= SUBSTR (READBUF,0,1) AND
      '.' ~= SUBSTR (READBUF,0,1));
      READBUF = ' ';
      CALL M$READ (READIN) ALTRET (ERR);
      CALL TESTCHAR (READBUF);
      END;
  IF M$SI$->F$DCB.ARS# = 0
    THEN DO;
      READBUF = 'None.';
      END;
    ELSE DO;
      DO WHILE (M$SI$->F$DCB.ARS# >
          (RMARGIN - KEYSTART - LENGTHC(NAME)));
          WRITEOUT.V.DVBYTE.VFC# = NOTSET ;
          WRITEBUF = 'Name too long for one line with margins as specified, try again!';
          CALL M$WRITE (WRITEOUT) ALTRET (ERR);
          WRITEOUT.V.DVBYTE.VFC# = SET ;
          REREADBUF = READBUF;
          READIN.V.DVBYTE.REREAD# = SET;
          BAKTOUSER.BUF_ = VECTOR( SUBSTR( READBUF,0,M$SI$->F$DCB.ARS#));
          CALL M$SINPUT (BAKTOUSER) ALTRET (ERR);
          READBUF = ' ';
          CALL M$READ (READIN) ALTRET (ERR);
          READIN.V.DVBYTE.REREAD# = NOTSET;
          END;
      END;
  WRITEBUF = ' ';
  CALL INSERT (WRITEBUF,KEYSTART,RMARGIN-KEYSTART,NAME);
  CALL CONCAT (DOCBUF,SUBSTR(WRITEBUF,0,
      KEYSTART+LENGTHC(NAME)),READBUF);
  CALL WRITE ;
  RETURN;
ERR: ;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
END SETHEAD;
 
SETEND: PROC;
  CALL CONCAT (DOCBUF,STAR,SLASH);
  CALL WRITE ;
END SETEND ;
 
SET_PROMPT: PROC (PROMPTEXT,LENTH);
  DCL PROMPTEXT CHAR (15) CALIGNED;
  DCL LENTH UBIN ;
  DCL 1 PROMTCARS ALIGNED STATIC,
        2 * CHAR (1) CALIGNED INIT ('*'),
        2 TYPE CHAR (1) CALIGNED INIT (' '),
        2 * CHAR (2) CALIGNED INIT ('* '),
        2 TEXT CHAR (15) CALIGNED INIT (' ');
  DCL PROMTSTR REDEF PROMTCARS CHAR (19) ALIGNED;
  PROMTCARS.TYPE = DOCTYPE;
  PROMTCARS.TEXT = PROMPTEXT;
  PROMPTN.PROMPT_ = VECTOR(SUBSTR(PROMTSTR,0,LENTH+4));
  CALL M$PROMPT (PROMPTN) ALTRET (ERR);
 
  RETURN;
ERR: ;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
END SET_PROMPT;
 
DOTEXT : PROC (HEAD,P_FLAG);
  DCL HEAD CHAR (15) CALIGNED;
  DCL HDLEN UBIN;
  DCL REALHDLEN UBIN;
  DCL FLAG BIT (1) ALIGNED;
  DCL P_FLAG BIT (1) ALIGNED;
  DCL INPUTSIZE UBIN;
  DCL LINELEN UBIN ;
  HDLEN = %IOBUFSIZE;
  CALL INDEX (HDLEN,':',HEAD);
  REALHDLEN = HDLEN + 1;
  IF KEYRIGHT
    THEN DO;
      KEYSTART = KEYSTARTSAVE - REALHDLEN;
      END;
    ELSE DO;
      KEYSTART = KEYSTARTSAVE;
      END;
  IF KEYSTART < 0
    THEN DO;
      KEYSTART = 0;
      END;
  LINELEN = (RMARGINDOC - LMARGINTEXT);
  IF ADDR(P_FLAG) = ADDR (NIL)
    THEN DO;
      FLAG = NOTSET;
      END;
    ELSE DO;
      FLAG = SET;
      END;
  CALL CONCAT (HELP_TOPIC,DOCTYPE,SUBSTR(HEAD,0,HDLEN));
  HELP_LENGTH = REALHDLEN;
  HELP_DOC.V.MORE# = '0'B;
  CALL SET_PROMPT (SUBSTR(HEAD,0,REALHDLEN),REALHDLEN);
  DO UNTIL ('?' ~= SUBSTR (READBUF,0,1) AND
      '+' ~= SUBSTR (READBUF,0,1) AND
      '.' ~= SUBSTR (READBUF,0,1));
      READBUF = ' ';
      CALL M$READ (READIN) ALTRET (ERR);
      CALL TESTCHAR (READBUF);
      END;
  INPUTSIZE = M$SI$->F$DCB.ARS# ;
  IF INPUTSIZE = 0 AND FLAG = SET AND %CR = M$SI$->F$DCB.EOMCHAR#
    THEN DO ;
      READBUF = 'None.';
      END;
  IF INPUTSIZE > 0 OR (FLAG = SET AND %CR = M$SI$->F$DCB.EOMCHAR#)
    THEN DO;
      DOCBUF = ' ';
      CALL INSERT (DOCBUF,KEYSTART,,
          SUBSTR(HEAD,0,REALHDLEN));
      CALL WRITE ;
      IF FLAG = SET AND INPUTSIZE = 0
        THEN DO;
          DOCBUF = ' ';
          CALL INSERT (DOCBUF,LMARGINTEXT,LINELEN,READBUF);
          CALL WRITE ;
          END;
 /* Write line of text next, above writes the word 'NONE'*/
      DO WHILE (INPUTSIZE > 0);
          IF '.' ~= SUBSTR (READBUF,0,1) AND
              '+' ~= SUBSTR (READBUF,0,1) AND
              '?' ~= SUBSTR (READBUF,0,1)
            THEN DO;
              CALL SETEXT (INPUTSIZE,LINELEN);
              END;
          READBUF = ' ';
          CALL M$READ (READIN) ALTRET (ERR);
          CALL TESTCHAR (READBUF);
          INPUTSIZE = M$SI$->F$DCB.ARS# ;
          END;
      END;
 
  RETURN;
ERR: ;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
END DOTEXT;
 
SETEXT: PROC (INPUTSIZE,LINELEN);
  DCL INPUTSIZE UBIN;
  DCL LINELEN UBIN;
  DCL START UBIN;
  DCL OLD_START UBIN;
  DCL TRACE UBIN;
  DCL END_OF_TEXT_LINE UBIN;
  DCL BLANKPOS UBIN;
  DCL BLANK BIT (1) ALIGNED;
  IF INPUTSIZE <= LINELEN
    THEN DO;
      DOCBUF = ' ';
      CALL INSERT (DOCBUF,LMARGINTEXT,LINELEN,READBUF);
      CALL WRITE ;
      INPUTSIZE = 0;
      READIN.V.DVBYTE.REREAD# = NOTSET;
      END;
    ELSE DO;
      START = 0;
      DO WHILE ( (INPUTSIZE - START) >= LINELEN);
          CALL INDEX1R (BLANKPOS,' ',SUBSTR (READBUF,START,LINELEN)) ALTRET (NO_BLANK);
          DOCBUF = ' ';
          CALL INSERT (DOCBUF,LMARGINTEXT,,
              SUBSTR(READBUF,START,BLANKPOS)) ALTRET (ERR);
          CALL WRITE;
          START = START + BLANKPOS + 1;
          GOTO ENDO ;
NO_BLANK : ;
          DOCBUF = ' ';
          CALL INSERT (DOCBUF,LMARGINTEXT,,
              SUBSTR (READBUF,START,LINELEN)) ALTRET (ERR);
          CALL WRITE;
          START = START + LINELEN;
ENDO:     END; /* Do while                                                    */
      IF START < INPUTSIZE
        THEN DO;
          READIN.V.DVBYTE.REREAD# = SET ;
          REREADBUF = SUBSTR (READBUF,START,(INPUTSIZE - START));
          BAKTOUSER.BUF_ = VECTOR (SUBSTR (READBUF,START,(INPUTSIZE - START)));
          CALL M$SINPUT (BAKTOUSER) ALTRET (ERR);
          END;
      END;
 
  RETURN;
ERR: ;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
END SETEXT;
 
EDITFILE:PROC;
  CALL M$UNFID (GET_FILE_NAME) ALTRET (ERR);
  CMD_STRING.TEXT.EDIT_FID = OUT_FILE_NAME;
  CALL M$CLOSE ( CLOSE_OU) ALTRET (ERR);
  CALL M$LINK (INTO_EDIT) ALTRET (ERR);
  CALL M$OPEN ( OPEN_OU) ALTRET (ERR);
  RETURN;
ERR: ;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
END EDITFILE;
 
WRITE: PROC ;
  DCL I UBIN;
  I = %IOBUFSIZE - 1;
  DO WHILE ((' ' = SUBSTR (DOCBUF,I,1)) AND (I > 1));
      I = I - 1;
      END;
  WRITEDOC.BUF_ = VECTOR ( SUBSTR (DOCBUF,0,(I + 1)));
  CALL M$WRITE (WRITEDOC) ALTRET (ERR);
  EDITKEY.COUNT = EDITKEY.COUNT + KEY_INCREMENT;
  RETURN;
ERR: ;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
END WRITE ;
 
BUILD_KEY: PROC(KEY, NODE_PTR$);
  DCL KEY UBIN;
  DCL NODE_PTR$ PTR;
  DCL FRAC UBIN;
  DCL TEMPO UBIN;
  KEY = 0;
  FRAC = 0;
  TEMPO = 0;
  DO CASE (NODE_PTR$ -> OPT$SYM.CODE);
     CASE (%$INT_KEY);
       CALL CHARBIN (TEMPO, NODE_PTR$ -> OPT$OUT.SUBLK$(0) -> OPT$SYM.TEXT);
       KEY = TEMPO * 1000;
     CASE (%$FRAC_KEY);
       DO CASE (NODE_PTR$ -> OPT$OUT.SUBLK$(0) -> OPT$SYM.COUNT);
          CASE (1);
            CALL CHARBIN (TEMPO, NODE_PTR$ -> OPT$OUT.SUBLK$(0) -> OPT$SYM.TEXT);
            FRAC = TEMPO * 100;
          CASE (2);
            CALL CHARBIN (TEMPO, NODE_PTR$ -> OPT$OUT.SUBLK$(0) -> OPT$SYM.TEXT);
            FRAC = TEMPO * 10;
          CASE (3);
            CALL CHARBIN (FRAC, NODE_PTR$ -> OPT$OUT.SUBLK$(0) -> OPT$SYM.TEXT);
          CASE (ELSE);
            FRAC = 0;
          END; /* Do case                                                     */
     CASE (%$MIXED_KEY);
       CALL CHARBIN (TEMPO, NODE_PTR$ -> OPT$OUT.SUBLK$(0) -> OPT$SYM.TEXT);
       KEY = TEMPO * 1000;
       DO CASE (NODE_PTR$ -> OPT$OUT.SUBLK$(1) -> OPT$SYM.COUNT);
          CASE (1);
            CALL CHARBIN (TEMPO, NODE_PTR$ -> OPT$OUT.SUBLK$(1) -> OPT$SYM.TEXT);
            FRAC = TEMPO * 100;
          CASE (2);
            CALL CHARBIN (TEMPO, NODE_PTR$ -> OPT$OUT.SUBLK$(1) -> OPT$SYM.TEXT);
            FRAC = TEMPO * 10;
          CASE (3);
            CALL CHARBIN (FRAC, NODE_PTR$ -> OPT$OUT.SUBLK$(1) -> OPT$SYM.TEXT);
          CASE (ELSE);
            FRAC = 0;
          END; /* Do case                                                     */
     END; /* Do case                                                          */
  KEY = KEY + FRAC;
END BUILD_KEY;
 
GOTO_END:PROC;
  CALL M$PFIL (END_OF_FILE) ALTRET (ERR);
  CALL M$PRECORD ( FIND_END) ALTRET (ERR);
  DO WHILE (KEY_BUF.KEY_VAL >= EDITKEY.COUNT);
      EDITKEY.COUNT = EDITKEY.COUNT + KEY_INCREMENT ;
      END;
  RETURN;
ERR: ;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
END GOTO_END;
 
BUILD_PLUS:PROC;
  DCL LINES CHAR (12) CALIGNED ;
  DCL TEMP_COM CHAR (%IOBUFSIZE);
  DCL COMMA_POS UBIN WALIGNED;
  DCL NEWNUM UBIN;
  DCL TESTCHAR SBIN;
  DCL INITIALS CHAR (8) CALIGNED;
  CALL CHARBIN(TESTCHAR, SUBSTR(READBUF,1,1));
  IF TESTCHAR > 9 OR
      TESTCHAR <= 0 OR
      M$SI$->F$DCB.ARS# <= 1
    THEN DO;
      WRITEOUT.V.DVBYTE.VFC# = NOTSET;
      WRITEBUF =
          'Proper syntax is either +LINE# or +LINE#,LINE#, please retry';
      CALL M$WRITE (WRITEOUT) ALTRET(ERR);
      WRITEOUT.V.DVBYTE.VFC# = SET;
      RETURN;
      END;
  LINES = SUBSTR(READBUF,0,M$SI$->F$DCB.ARS#) ;
  CALL M$TIME (GET_DATE) ALTRET (ERR);
  INITIALS = B$JIT$->B$JIT.ACCN;
  CALL CONCAT (TEMP_COM,BLANK,COM_FLD);
  CALL CONCAT (DOCBUF,LINES,BLANK,INITIALS,BLANK,DATEVAL,TEMP_COM);
  COMMA_POS = %IOBUFSIZE;
  CALL INDEX (COMMA_POS,',',LINES)
    WHENALTRETURN DO;
      CALL INDEX (COMMA_POS,' ',LINES);
      END;
  CALL CHARBIN (NEWNUM,SUBSTR(LINES,1,COMMA_POS-1));
  EDITKEY.COUNT = NEWNUM * 1000;
  IF KEY_INCREMENT <= 1000
    THEN DO;
      KEY_INCREMENT = 10;
      END;
  CALL WRITE;
  RETURN;
ERR: ;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
END BUILD_PLUS;
 
RESET_COMMENT: PROC;
  DCL ST UBIN;
  DCL EN UBIN;
  ST = 0;
  EN = %IOBUFSIZE;
  IF M$SI$->F$DCB.ARS# <= 2
    THEN DO;
      WRITEOUT.V.DVBYTE.VFC# = NOTSET;
      WRITEBUF =
          'Proper syntax is .C(comment field) ';
      CALL M$WRITE (WRITEOUT) ALTRET(ERR);
      WRITEOUT.V.DVBYTE.VFC# = SET;
      RETURN;
      END;
  CALL INDEX (ST,'(',READBUF)
    WHENALTRETURN DO;
      WRITEOUT.V.DVBYTE.VFC# = NOTSET;
      WRITEBUF =
          'Proper syntax is .C(comment field) ';
      CALL M$WRITE (WRITEOUT) ALTRET(ERR);
      WRITEOUT.V.DVBYTE.VFC# = SET;
      RETURN;
      END;
  CALL INDEX (EN,')',READBUF)
    WHENALTRETURN DO;
      WRITEOUT.V.DVBYTE.VFC# = NOTSET;
      WRITEBUF =
          'Proper syntax is .C(comment field) ';
      CALL M$WRITE (WRITEOUT) ALTRET(ERR);
      WRITEOUT.V.DVBYTE.VFC# = SET;
      RETURN;
      END;
  IF (EN - ST) > (RMARGINDOC - 31)
    THEN DO;
      WRITEOUT.V.DVBYTE.VFC# = NOTSET;
      WRITEBUF =
          'Comment is longer than margins allow, it will be truncated!';
      CALL M$WRITE (WRITEOUT) ALTRET(ERR);
      WRITEOUT.V.DVBYTE.VFC# = SET;
      EN = RMARGINDOC - 30 + ST;
      END;
  ST = ST + 1;
  COM_FLD = SUBSTR (READBUF,ST,EN-ST);
  RETURN;
ERR: ;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
END RESET_COMMENT;
 
RESET_INCREMENT: PROC;
  DCL NUM UBIN;
  NUM = 0;
  CALL NUMBER (NUM);
  IF NUM > 0
    THEN DO;
      KEY_INCREMENT = NUM;
      END;
END RESET_INCREMENT;
 
RESET_START: PROC;
  DCL NUM UBIN;
  NUM = 0;
  CALL NUMBER (NUM);
  IF NUM > 0
    THEN DO;
      EDITKEY.COUNT = NUM;
      END;
END RESET_START;
 
NUMBER:PROC (NUM);
  DCL DIG_INDEX UBIN;
  DCL DIGIT UBIN;
  DCL POINT UBIN;
  DCL PRE UBIN;
  DCL POST_COUNT UBIN;
  DCL POST UBIN;
  DCL NUM UBIN;
  DCL TEMP_INBUF CHAR (50) ALIGNED STATIC;
  PRE = 0;
  POST = 0;
  NUM = 0;
  POST_COUNT = 0;
  DIG_INDEX = 1;
  CALL INDEX (DIG_INDEX,'=',READBUF);
  IF ('=' ~= SUBSTR (READBUF,DIG_INDEX,1))
    THEN DO;
      WRITEBUF =
          'Bad syntax for command, it should be ''.I(or S)=line#'' with no blanks.';
      CALL M$WRITE (WRITEOUT) ALTRET (ERR);
      RETURN;
      END;
  POINT = DIG_INDEX - 1;
  TEMP_INBUF = SUBSTR ( READBUF,1,50);
  CALL INDEX (POINT,'.',TEMP_INBUF);
  IF ('.' = SUBSTR (TEMP_INBUF,POINT,1))
    THEN DO;
      POINT = POINT - 1;
      IF ((POINT - DIG_INDEX) >= 0)
        THEN DO;
          CALL CHARBIN (PRE, SUBSTR(TEMP_INBUF,DIG_INDEX,(POINT-DIG_INDEX+1)));
          END;
      DIG_INDEX = POINT + 2;
      DO WHILE (( '0' <= SUBSTR (TEMP_INBUF,DIG_INDEX,1)) AND
          ( '9' >= SUBSTR (TEMP_INBUF,DIG_INDEX,1)));
          CALL CHARBIN (DIGIT, SUBSTR (TEMP_INBUF,DIG_INDEX,1)) ;
          DIG_INDEX = DIG_INDEX + 1;
          POST = (POST * 10) + DIGIT;
          POST_COUNT = POST_COUNT + 1;
          END;
      IF (POST_COUNT > 3)
        THEN DO;
          WRITEBUF =
              'Too large a post decimal value, I will ignore it.';
          CALL M$WRITE (WRITEOUT) ALTRET(ERR);
          DO WHILE (POST_COUNT > 3);
              POST = POST / 10;
              POST_COUNT = POST_COUNT - 1;
              END;
          END;
      DO WHILE (POST_COUNT < 3);
          POST = POST * 10;
          POST_COUNT = POST_COUNT + 1;
          END;
      NUM = (PRE * 1000) + POST;
      END;
    ELSE DO;
      DO WHILE (( '0' <= SUBSTR (TEMP_INBUF,DIG_INDEX,1)) AND
          ( '9' >= SUBSTR (TEMP_INBUF,DIG_INDEX,1)));
          CALL CHARBIN (DIGIT, SUBSTR (TEMP_INBUF,DIG_INDEX,1)) ;
          DIG_INDEX = DIG_INDEX + 1;
          PRE = (PRE * 10) + DIGIT;
          END;
      NUM = PRE * 1000;
      END;
  IF (PRE > 99999)
    THEN DO;
      WRITEBUF =
          'Too large a pre-decimal digit, start/increment not being changed.';
      CALL M$WRITE (WRITEOUT) ALTRET (ERR);
      NUM = 0;
      END;
  RETURN;
ERR: ;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
END NUMBER;
 
DOT_HELP: PROC;
  WRITEOUT.V.DVBYTE.VFC# = NOTSET;
  WRITEBUF =
      '  The commands available inside Edict are:';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      ' ';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '        +line#[,line#]   -This is the syntax of the command which';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '                          will build a plus card at the first line';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '                          number specified.  Documentation will then';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '                          continue being inserted after that line in';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '                          the file.  The increment will then default';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '                          to count the edit key in .01 increments.';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      ' ';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '        .C(comment field) -The comment field will become the plus';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '                           cards comment field.';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      ' ';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '        .E                -This command puts you into edit of the';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '                           documentation you are creating.  Be SURE';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '                           you RESET the key of the next record to';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '                           be created in the documentation file if';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '                           you insert new lines at the end of the';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '                           file while in edit.';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      ' ';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '        .I=line#          -This command lets you change the value of';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '                           the increment of the edit keys.  The same';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '                           thing as the I option for invocation.';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      ' ';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '        .S=line#          -This command lets you change the value of';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '                           the line number of the next edit key.';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '                           This is the same as the S option in the';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      '                           invocation of EDICT.';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEBUF =
      ' ';
  CALL M$WRITE (WRITEOUT) ALTRET(ERR);
  WRITEOUT.V.DVBYTE.VFC# = SET;
 
  RETURN;
ERR: ;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
END DOT_HELP;
 
  RETURN;
ERR: ;
  MERR.CODE_ = VECTOR( B$TCB$->B$TCB.ALT$->B$ALT.ERR) ;
  CALL M$ERRMSG ( MERR) ;
  CALL M$CLOSE ( CLOSE_SI);
  CALL M$CLOSE ( CLOSE_OU);
  CALL M$CLOSE ( CLOSE_LO);
END EDICT;
