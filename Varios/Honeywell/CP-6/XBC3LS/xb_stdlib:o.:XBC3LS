
PL6.E3A0      #001=ATEXIT File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:22 Page:1    
        1        1        /*T***********************************************************/
        2        2        /*T*                                                         */
        3        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
        4        4        /*T*                                                         */
        5        5        /*T***********************************************************/
        6        6        atexit: PROC (func);
        7        7        /*D* PROTOTYPE:   int atexit ( void (*func)() )
        8        8             DESCRIPTION: atexit "registers" a function so that it will be
        9        9                          called when the main calls exit() or the main
       10       10                          function returns.
       11       11             RAP Nov 11, 1988
       12       12        */
       13       13
       14       14        %INCLUDE CP_6;
       15     5574
       16     5575    1   DCL func EPTR;
       17     5576
       18     5577    1   DCL funny_ptr PTR;
       19     5578    1   DCL real_func REDEF funny_ptr EPTR;
       20     5579
       21     5580    1   DCL 1 at_exit_list EXT,
       22     5581    1         2 in_use UBIN WORD INIT(0),
       23     5582    1         2 routines(0:32) EPTR;
       24     5583
       25     5584    1   DCL XB_RETURN_ORDINAL_RESULT ENTRY(1);
       26     5585
       27     5586    1   IF (at_exit_list.in_use>=32) THEN CALL XB_RETURN_ORDINAL_RESULT(1);
       28     5587
       29     5588    1   funny_ptr = ADDR(func);
       30     5589    1   at_exit_list.in_use = at_exit_list.in_use + 1;
       31     5590    1   at_exit_list.routines(at_exit_list.in_use) = real_func;
       32     5591
       33     5592    1   CALL XB_RETURN_ORDINAL_RESULT(0);
       34     5593
       35     5594    1   END atexit;
       36     5595        %EOD;

PL6.E3A0      #001=ATEXIT File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:22 Page:2    
--  Include file information  --

   CP_6_C.:LIB_E04  is referenced.
   CP_6.:LIB_E04  cannot be made into a system file and is referenced.
      No diagnostics issued in procedure ATEXIT.

   Procedure ATEXIT requires 21 words for executable code.
   Procedure ATEXIT requires 6 words of local(AUTO) storage.

PL6.E3A0      #001=ATEXIT File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:22 Page:3    
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #001=ATEXIT File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:22 Page:4    
          MINI XREF LISTING

AT_EXIT_LIST.IN_USE
      5581**DCL      5586>>IF       5589<<ASSIGN   5589>>ASSIGN   5590>>ASSIGN
AT_EXIT_LIST.ROUTINES
      5582**DCL      5590<<ASSIGN
FUNC
      5575**DCL         6--PROC     5588--ASSIGN
FUNNY_PTR
      5577**DCL      5578--REDEF    5588<<ASSIGN
REAL_FUNC
      5578**DCL      5590>>ASSIGN
XB_RETURN_ORDINAL_RESULT
      5584**DCL-ENT  5586--CALL     5592--CALL

PL6.E3A0      #002=REALLOC File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:5    
       37        1        /*T***********************************************************/
       38        2        /*T*                                                         */
       39        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
       40        4        /*T*                                                         */
       41        5        /*T***********************************************************/
       42        6
       43        7        realloc: PROC (old_ptr_P, size_in_chars_P);
       44        8           /*I*  NAME: realloc
       45        9                 PROTOTYPE: void *realloc (void *ptr, size_t size)
       46       10                 DESCRIPTION: realloc can be used to adjust the size of a block
       47       11              previously allocated by malloc or calloc.  ptr locates the block to
       48       12              be modified and size specifies the new size for it.  realloc will
       49       13              return a pointer.  The pointer returned may or may not have the same
       50       14              value as ptr.
       51       15                 There are a couple of special cases.  If ptr is nil, realloc works
       52       16              like malloc, returning a pointer to a block of size bytes.
       53       17                 If size is zero, any storage located by ptr will be freed and a null
       54       18              pointer will be returned.
       55       19                 If the storage requested cannot be allocated, a null pointer will be
       56       20              returned.
       57       21           */
       58       22
       59       23           %INCLUDE xb_heap_i6;
       60       98
       61       99    1      DCL old_ptr_P              PTR;
       62      100    1      DCL size_in_chars_P        UBIN;
       63      101
       64      102    1      DCL old_ptr                PTR;
       65      103    1      DCL 1 old_ptr_exposed REDEF old_ptr,
       66      104    1         2  word_offset          UBIN (18) UNAL,
       67      105    1         2  byte_bit_segid       UBIN (18) UNAL;
       68      106    1      DCL size_in_chars_as_ptr   PTR;
       69      107    1      DCL size_in_chars REDEF size_in_chars_as_ptr UBIN;
       70      108
       71      109    1      DCL needed_words           UBIN; /* minimum size of block returned */
       72      110    1      DCL space_to_free          UBIN; /* space that can be freed */
       73      111    1      DCL space_needed           UBIN; /* additional words needed */
PL6.E3A0      #002=REALLOC File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:6    
       74      112    1      DCL p                      PTR;  /* pointer to Head of block */
       75      113    1      DCL Tail_p                 PTR;  /* pointer to Tail of block */
       76      114    1      DCL Next_p                 PTR;  /* pointer to Head of next block */
       77      115    1      DCL bytes_to_move          UBIN;
       78      116    1      DCL old_data               CHAR (bytes_to_move) BASED (old_ptr);
       79      117    1      DCL new_data               CHAR (bytes_to_move) BASED (new_ptr);
       80      118    1      DCL new_ptr                PTR;
       81      119
       82      120    1      DCL XBI_MALLOC             ENTRY (2);
       83      121    1      DCL XBI_FREE               ENTRY (1);
       84      122    1      DCL XB_RETURN_ORDINAL_RESULT  ENTRY (1);
       85      123
       86      124           %EQU epsilon = 4;    /* minimum data size of freed block in words */
       87      125           %HEAP_SYMREF;
       88      140
       89      141    1      free_space: PROC;
       90      142              /* This procedure is called when we know there is enough
       91      143                 "extra" space in the block to make it worthwhile
       92      144                 chopping off some space at the end to create a new
       93      145                 block that can be added to the free list.
       94      146              */
       95      147
       96      148    2      DCL Next_Tail              PTR;  /* pointer to Tail of next block */
       97      149
       98      150    3         DO INHIBIT;
       99      151    3            p -> Head.Size = needed_words;
      100      152    3            Tail_p = PINCRW (p, needed_words - SIZEW (Tail));
      101      153    3            Tail_p -> Tail.Up_Link = p;
      102      154                 /* make the remaining space look like an allocated block and get
      103      155                    XBI_FREE to put it back into the free list. */
      104      156    3            Next_p = PINCRW (p, needed_words);
      105      157    3            Next_p -> Head.Size = space_to_free;
      106      158    3            Next_p -> Head.Flags       = '0'B;
      107      159    3            Next_p -> Head.Flags.Tag   = '1'B;
      108      160    3            Next_p -> Head.Flags.Stamp = 88;
      109      161    3            Next_p -> Head.Right_Link = ADDR(NIL);
      110      162    3            Next_p -> Head.Left_Link = ADDR(NIL);
PL6.E3A0      #002=REALLOC File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:7    
      111      163    3            Next_Tail = PINCRW (Next_p, space_to_free - SIZEW (Tail));
      112      164    3            Next_Tail -> Tail.Up_Link = Next_p;
      113      165    3         END /* INHIBIT */;
      114      166    2         CALL XBI_FREE (PINCRW (Next_p, SIZEW (Head)));
      115      167    2      END free_space;
      116      168
      117      169    1      old_ptr = ADDR (old_ptr_P);
      118      170    1      size_in_chars_as_ptr = ADDR (size_in_chars_P);
      119      171
      120      172           /* CASE 1: A size of zero was specified */
      121      173
      122      174    2      IF size_in_chars = 0 THEN DO;
      123      175    2         IF old_ptr ~= ADDR(NIL) THEN CALL XBI_FREE (old_ptr);
      124      176    2         CALL XB_RETURN_ORDINAL_RESULT (ADDR (NIL));
      125      177    2         RETURN;
      126      178    2      END;
      127      179
      128      180           /* CASE 2: old_ptr is null so just do an malloc */
      129      181
      130      182    2      IF old_ptr = ADDR(NIL) THEN DO;
      131      183    2         CALL XBI_MALLOC (size_in_chars, new_ptr);
      132      184    2         CALL XB_RETURN_ORDINAL_RESULT (new_ptr);
      133      185    2         RETURN;
      134      186    2      END;
      135      187
      136      188           /* CASE 3: old_ptr doesn't point into the heap.  return null. */
      137      189
      138      190    1      IF old_ptr_exposed.byte_bit_segid ~=
      139      191    2            XBI$Allocation_Heap.Heap_.Base.Byte_Bit_Segid THEN DO;
      140      192    2         CALL XB_RETURN_ORDINAL_RESULT (ADDR(NIL));
      141      193    2         RETURN;
      142      194    2      END;
      143      195
      144      196    1      needed_words = ((size_in_chars + 3) / 4) + SIZEW(Head) + SIZEW(Tail);
      145      197    1      IF MOD(needed_words, 2) = 1 THEN needed_words = needed_words + 1;
      146      198
      147      199    1      p = PINCRW (old_ptr, -SIZEW(Head));
PL6.E3A0      #002=REALLOC File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:8    
      148      200
      149      201           /* CASE 3.1: something's funny if the Stamp field doesn't contain
      150      202                        the magic value
      151      203           */
      152      204
      153      205    2      IF p -> Head.Flags.Stamp ~= 88 THEN DO;
      154      206    2         CALL XB_RETURN_ORDINAL_RESULT (ADDR(NIL));
      155      207    2         RETURN;
      156      208    2      END;
      157      209
      158      210
      159      211           /* CASE 4: The user is asking for a smaller block */
      160      212
      161      213    2      IF needed_words <= p->Head.Size THEN DO;
      162      214    2         space_to_free = p->Head.Size - needed_words;
      163      215    3         IF space_to_free >= (SIZEW(Head) + SIZEW(Tail) + %epsilon) THEN DO;
      164      216                 /* It's worth splitting the block in two */
      165      217    3            CALL free_space;
      166      218    3         END;
      167      219    2         CALL XB_RETURN_ORDINAL_RESULT (old_ptr);
      168      220    2         RETURN;
      169      221    2      END;
      170      222
      171      223           /* User wants a larger block */
      172      224
      173      225    1      space_needed = needed_words - p->Head.Size;
      174      226    1      Next_P = PINCRW (p, p->Head.Size);
      175      227
      176      228           /* CASE 5: Use malloc to get a new block, copy the data to the new block
      177      229                      and then free the old block.
      178      230           */
      179      231
      180      232    1      IF Next_p = XBI$Last_AV OR Next_P->Head.Flags.Tag OR
      181      233    2            (Next_p->Head.Size < space_needed) THEN DO;
      182      234    2         CALL XBI_MALLOC (size_in_chars, new_ptr);
      183      235    3         IF new_ptr ~= ADDR(NIL) THEN DO;
      184      236    3            bytes_to_move = (p->Head.Size - SIZEW(Head) - SIZEW(Tail)) * 4;
PL6.E3A0      #002=REALLOC File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:9    
      185      237    3            new_data = old_data;
      186      238    3            CALL XBI_FREE (old_ptr);
      187      239    3         END;
      188      240    2         CALL XB_RETURN_ORDINAL_RESULT (new_ptr);
      189      241    2         RETURN;
      190      242    2      END;
      191      243
      192      244           /* The next contiguous block is free and has enough space
      193      245              so we'll combine it with the current block
      194      246           */
      195      247
      196      248    2      DO INHIBIT;
      197      249    2         Next_p -> Head.Left_Link -> Head.Right_Link = Next_P -> Head.Right_Link;
      198      250    2         Next_p -> Head.Right_Link -> Head.Left_Link = Next_P -> Head.Left_Link;
      199      251    2         XBI$AV = Next_p -> Head.Left_Link;
      200      252              /* free list may be exhausted */
      201      253    2         IF XBI$AV = Next_p THEN XBI$AV = ADDR(NIL);
      202      254    2         space_to_free = Next_p -> Head.Size - space_needed;
      203      255
      204      256           /* CASE 6: All the space in the block is needed */
      205      257
      206      258    3         IF space_to_free < (SIZEW(Head) + SIZEW(Tail) + %epsilon) THEN DO;
      207      259    3            p -> Head.Size = p -> Head.Size + Next_p -> Head.Size;
      208      260    3            Tail_p = PINCRW (p, p->Head.Size - SIZEW(Tail));
      209      261    3            Tail_p -> Tail.Up_Link = p;
      210      262    3            CALL XB_RETURN_ORDINAL_RESULT (old_ptr);
      211      263    3            RETURN;
      212      264    3         END;
      213      265    2      END /* INHIBIT */;
      214      266
      215      267           /* CASE 7: Too much extra space in the block. */
      216      268
      217      269    1      CALL free_space;
      218      270    1      CALL XB_RETURN_ORDINAL_RESULT (old_ptr);
      219      271    1   END realloc;
      220      272        %EOD;

PL6.E3A0      #002=REALLOC File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:10   
--  Include file information  --

   xb_heap_i6.:XBC3TOU  cannot be made into a system file and is referenced.
      No diagnostics issued in procedure REALLOC.

   Procedure REALLOC requires 242 words for executable code.
   Procedure REALLOC requires 20 words of local(AUTO) storage.

PL6.E3A0      #002=REALLOC File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:11   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #002=REALLOC File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:12   
          MINI XREF LISTING

BYTES_TO_MOVE
       115**DCL       116--IMP-SIZ   117--IMP-SIZ   236<<ASSIGN    237>>ASSIGN    237>>ASSIGN
FREE_SPACE
       141**PROC      217--CALL      269--CALL
HEAD
        76**DCL       166--CALL      196--ASSIGN    199--ASSIGN    215--IF        236--ASSIGN    258--IF
HEAD.FLAGS
        80**DCL       158<<ASSIGN
HEAD.FLAGS.STAMP
        87**DCL       160<<ASSIGN    205>>IF
HEAD.FLAGS.TAG
        81**DCL       159<<ASSIGN    232>>IF
HEAD.LEFT_LINK
        77**DCL       162<<ASSIGN    249>>ASSIGN    250<<ASSIGN    250>>ASSIGN    251>>ASSIGN
HEAD.RIGHT_LINK
        78**DCL       161<<ASSIGN    249<<ASSIGN    249>>ASSIGN    250>>ASSIGN
HEAD.SIZE
        79**DCL       151<<ASSIGN    157<<ASSIGN    213>>IF        214>>ASSIGN    225>>ASSIGN    226>>ASSIGN
       232>>IF        236>>ASSIGN    254>>ASSIGN    259<<ASSIGN    259>>ASSIGN    259>>ASSIGN    260>>ASSIGN
NEEDED_WORDS
       109**DCL       151>>ASSIGN    152>>ASSIGN    156>>ASSIGN    196<<ASSIGN    197>>IF        197<<ASSIGN
       197>>ASSIGN    213>>IF        214>>ASSIGN    225>>ASSIGN
NEW_DATA
       117**DCL       237<<ASSIGN
NEW_PTR
       118**DCL       117--IMP-PTR   183<>CALL      184<>CALL      234<>CALL      235>>IF        237>>ASSIGN
       240<>CALL
NEXT_P
       114**DCL       156<<ASSIGN    157>>ASSIGN    158>>ASSIGN    159>>ASSIGN    160>>ASSIGN    161>>ASSIGN
       162>>ASSIGN    163>>ASSIGN    164>>ASSIGN    166>>CALL      226<<ASSIGN    232>>IF        232>>IF
       232>>IF        249>>ASSIGN    249>>ASSIGN    250>>ASSIGN    250>>ASSIGN    251>>ASSIGN    253>>IF
       254>>ASSIGN    259>>ASSIGN
PL6.E3A0      #002=REALLOC File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:13   
NEXT_TAIL IN PROCEDURE FREE_SPACE
       148**DCL       163<<ASSIGN    164>>ASSIGN
OLD_DATA
       116**DCL       237>>ASSIGN
OLD_PTR
       102**DCL       103--REDEF     116--IMP-PTR   169<<ASSIGN    175>>IF        175<>CALL      182>>IF
       199>>ASSIGN    219<>CALL      237>>ASSIGN    238<>CALL      262<>CALL      270<>CALL
OLD_PTR_EXPOSED.BYTE_BIT_SEGID
       105**DCL       190>>IF
OLD_PTR_P
        99**DCL         7--PROC      169--ASSIGN
P
       112**DCL       151>>ASSIGN    152>>ASSIGN    153>>ASSIGN    156>>ASSIGN    199<<ASSIGN    205>>IF
       213>>IF        214>>ASSIGN    225>>ASSIGN    226>>ASSIGN    226>>ASSIGN    236>>ASSIGN    259>>ASSIGN
       259>>ASSIGN    260>>ASSIGN    260>>ASSIGN    261>>ASSIGN
SIZE_IN_CHARS
       107**DCL       174>>IF        183<>CALL      196>>ASSIGN    234<>CALL
SIZE_IN_CHARS_AS_PTR
       106**DCL       107--REDEF     170<<ASSIGN
SIZE_IN_CHARS_P
       100**DCL         7--PROC      170--ASSIGN
SPACE_NEEDED
       111**DCL       225<<ASSIGN    232>>IF        254>>ASSIGN
SPACE_TO_FREE
       110**DCL       157>>ASSIGN    163>>ASSIGN    214<<ASSIGN    215>>IF        254<<ASSIGN    258>>IF
TAIL
        89**DCL       152--ASSIGN    163--ASSIGN    196--ASSIGN    215--IF        236--ASSIGN    258--IF
       260--ASSIGN
TAIL.UP_LINK
        90**DCL       153<<ASSIGN    164<<ASSIGN    261<<ASSIGN
TAIL_P
       113**DCL       152<<ASSIGN    153>>ASSIGN    260<<ASSIGN    261>>ASSIGN
XBI$ALLOCATION_HEAP.HEAP_.BASE.BYTE_BIT_SEGID
       137**DCL       190>>IF
XBI$ALLOCATION_HEAP.HEAP_.BASE$
       134**DCL       135--REDEF
PL6.E3A0      #002=REALLOC File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:14   
XBI$AV
       126**DCL       251<<ASSIGN    253>>IF        253<<ASSIGN
XBI$LAST_AV
       128**DCL       232>>IF
XBI_FREE
       121**DCL-ENT   166--CALL      175--CALL      238--CALL
XBI_MALLOC
       120**DCL-ENT   183--CALL      234--CALL
XB_RETURN_ORDINAL_RESULT
       122**DCL-ENT   176--CALL      184--CALL      192--CALL      206--CALL      219--CALL      240--CALL
       262--CALL      270--CALL

PL6.E3A0      #003=CALLOC File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:15   
      221        1        /*T***********************************************************/
      222        2        /*T*                                                         */
      223        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
      224        4        /*T*                                                         */
      225        5        /*T***********************************************************/
      226        6
      227        7        calloc: PROC (nmemb_P, size_in_chars_P);
      228        8           /*D*  NAME: calloc
      229        9                 PROTOTYPE: void *calloc (size_t nmemb, size_t size);
      230       10                 DESCRIPTION: allocates space for nmemb items of size bytes and
      231       11              returns a pointer to the allocated space.  The allocated space is
      232       12              set to all zero bits.  If the space cannot be allocated, a null
      233       13              pointer is returned.
      234       14           */
      235       15
      236       16    1      DCL nmemb_P                UBIN;
      237       17    1      DCL size_in_chars_P        UBIN;
      238       18
      239       19    1      DCL nmemb_as_ptr           PTR;
      240       20    1      DCL nmemb REDEF nmemb_as_ptr UBIN;
      241       21    1      DCL size_in_chars_as_ptr   PTR;
      242       22    1      DCL size_in_chars REDEF size_in_chars_as_ptr UBIN;
      243       23
      244       24    1      DCL total_space_in_chars   UBIN;
      245       25    1      DCL result           PTR;
      246       26    1      DCL 1 struct_for_zeroing BASED (result),
      247       27    1         2  data           CHAR (total_space_in_chars);
      248       28
      249       29    1      DCL xb_return_ordinal_result     ENTRY (1);
      250       30    1      DCL xbi_malloc                   ENTRY (2);
      251       31
      252       32    1      nmemb_as_ptr = ADDR (nmemb_P); /* gross hack! */
      253       33    1      size_in_chars_as_ptr = ADDR(size_in_chars_P); /* gross hack! */
      254       34
      255       35    1      total_space_in_chars = nmemb * size_in_chars;
      256       36
      257       37           /* if they don't want any space, give them a null pointer */
PL6.E3A0      #003=CALLOC File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:16   
      258       38    1      if total_space_in_chars = 0 then CALL xb_return_ordinal_result (ADDR(NIL));
      259       39
      260       40    1      CALL xbi_malloc (total_space_in_chars, result);
      261       41    1      if result ~= ADDR(NIL) then
      262       42    1         struct_for_zeroing = '0'B;
      263       43    1      CALL xb_return_ordinal_result (result);
      264       44    1   END calloc;
      265       45        %EOD;

PL6.E3A0      #003=CALLOC File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:17   
      No diagnostics issued in procedure CALLOC.

   Procedure CALLOC requires 42 words for executable code.
   Procedure CALLOC requires 12 words of local(AUTO) storage.

PL6.E3A0      #003=CALLOC File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:18   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #003=CALLOC File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:19   
          MINI XREF LISTING

NMEMB
        20**DCL        35>>ASSIGN
NMEMB_AS_PTR
        19**DCL        20--REDEF      32<<ASSIGN
NMEMB_P
        16**DCL         7--PROC       32--ASSIGN
RESULT
        25**DCL        26--IMP-PTR    40<>CALL       41>>IF         42>>ASSIGN     43<>CALL
SIZE_IN_CHARS
        22**DCL        35>>ASSIGN
SIZE_IN_CHARS_AS_PTR
        21**DCL        22--REDEF      33<<ASSIGN
SIZE_IN_CHARS_P
        17**DCL         7--PROC       33--ASSIGN
STRUCT_FOR_ZEROING
        26**DCL        42<<ASSIGN
TOTAL_SPACE_IN_CHARS
        24**DCL        27--IMP-SIZ    35<<ASSIGN     38>>IF         40<>CALL       42>>ASSIGN
XBI_MALLOC
        30**DCL-ENT    40--CALL
XB_RETURN_ORDINAL_RESULT
        29**DCL-ENT    38--CALL       43--CALL

PL6.E3A0      #004=MALLOC File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:20   
      266        1        /*T***********************************************************/
      267        2        /*T*                                                         */
      268        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
      269        4        /*T*                                                         */
      270        5        /*T***********************************************************/
      271        6
      272        7        malloc: PROC (size_in_chars_P);
      273        8           /*D*  NAME: malloc
      274        9                 PROTOTYPE: void *malloc (size_t size);
      275       10                 DESCRIPTION: allocates space of size bytes and returns a pointer to
      276       11              the allocated space.  If size is zero or the requested space cannot be
      277       12              allocated, a null pointer is returned.
      278       13           */
      279       14
      280       15    1      DCL size_in_chars_P        UBIN;
      281       16
      282       17    1      DCL size_in_chars_as_ptr   PTR;
      283       18    1      DCL size_in_chars REDEF size_in_chars_as_ptr UBIN;
      284       19    1      DCL result           PTR;
      285       20
      286       21    1      DCL xb_return_ordinal_result     ENTRY (1);
      287       22    1      DCL xbi_malloc                   ENTRY (2);
      288       23
      289       24    1      size_in_chars_as_ptr = ADDR(size_in_chars_P); /* gross hack! */
      290       25
      291       26    1      if size_in_chars = 0 then CALL xb_return_ordinal_result (ADDR(NIL));
      292       27
      293       28    1      CALL xbi_malloc (size_in_chars, result);
      294       29    1      CALL xb_return_ordinal_result (result);
      295       30    1   END malloc;
      296       31        %EOD;

PL6.E3A0      #004=MALLOC File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:21   
      No diagnostics issued in procedure MALLOC.

   Procedure MALLOC requires 29 words for executable code.
   Procedure MALLOC requires 8 words of local(AUTO) storage.

PL6.E3A0      #004=MALLOC File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:22   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #004=MALLOC File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:23   
          MINI XREF LISTING

RESULT
        19**DCL        28<>CALL       29<>CALL
SIZE_IN_CHARS
        18**DCL        26>>IF         28<>CALL
SIZE_IN_CHARS_AS_PTR
        17**DCL        18--REDEF      24<<ASSIGN
SIZE_IN_CHARS_P
        15**DCL         7--PROC       24--ASSIGN
XBI_MALLOC
        22**DCL-ENT    28--CALL
XB_RETURN_ORDINAL_RESULT
        21**DCL-ENT    26--CALL       29--CALL

PL6.E3A0      #005=FREE File=xb_stdlib:6.:XBC3TSI                                FRI 01/06/95 11:23 Page:24   
      297        1        /*T***********************************************************/
      298        2        /*T*                                                         */
      299        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
      300        4        /*T*                                                         */
      301        5        /*T***********************************************************/
      302        6
      303        7        free: PROC (arg$);
      304        8           /*D*  NAME: free
      305        9                 PROTOTYPE: void free (void *ptr);
      306       10                 DESCRIPTION: frees storage previously allocated by malloc, calloc
      307       11              or realloc.  If ptr is null or does not point into the heap, the
      308       12              request is ignored.
      309       13           */
      310       14
      311       15    1      DCL arg$             PTR;
      312       16
      313       17    1      DCL xbi_free         ENTRY (1);
      314       18
      315       19    1      CALL xbi_free (ADDR(arg$));
      316       20    1   END free;
      317       21        %EOD;

PL6.E3A0      #005=FREE File=xb_stdlib:6.:XBC3TSI                                FRI 01/06/95 11:23 Page:25   
      No diagnostics issued in procedure FREE.

   Procedure FREE requires 11 words for executable code.
   Procedure FREE requires 6 words of local(AUTO) storage.

PL6.E3A0      #005=FREE File=xb_stdlib:6.:XBC3TSI                                FRI 01/06/95 11:23 Page:26   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #005=FREE File=xb_stdlib:6.:XBC3TSI                                FRI 01/06/95 11:23 Page:27   
          MINI XREF LISTING

ARG$
        15**DCL         7--PROC       19--CALL
XBI_FREE
        17**DCL-ENT    19--CALL

PL6.E3A0      #006=STRTOD File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:28   
      318        1        /*T***********************************************************/
      319        2        /*T*                                                         */
      320        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
      321        4        /*T*                                                         */
      322        5        /*T***********************************************************/
      323        6
      324        7        strtod: PROC (string, sub);
      325        8        /*D* PROTOTYPE:   double strtod (char *str, **ptr);
      326        9             DESCRIPTION: strtod converts a string to a number. Any leading
      327       10                          whitespace is skipped and then a number can consist
      328       11                          of an optional plus or minus sign, a sequence of
      329       12                          decimal digits (possible containing a single decimal
      330       13                          point) and an optional exponent part consisting of the
      331       14                          letter e or E, an optional sign and a sequence of
      332       15                          decimal digits. The value returned is converted from
      333       16                          the longest sequence that matches this model. If ptr
      334       17                          is not null then on return it points to the character
      335       18                          just past the last character used in the conversion.
      336       19        */
      337       20           %INCLUDE xb_errors_i6;
      338       91
      339       92    1      DCL string              CHAR (string_len);
      340       93    1      DCL string_len          SBIN;
      341       94    1      DCL sub                 PTR;
      342       95
      343       96    1      DCL result              BIT (72) DALIGNED;
      344       97
      345       98           %EQU tempstr_size     = 200;
      346       99    1      DCL chunk_length        UBIN;
      347      100    1      DCL negative_value      BIT(1);
      348      101    1      DCL XBI$non_whitespace_table (0:511) UBIN BYTE UNAL SYMREF READONLY;
      349      102    1      DCL overflow_error      BIT (1);
      350      103    1      DCL dont_set_errno      BIT (1)  ALIGNED;
      351      104    1      DCL start_index         UBIN;
      352      105    1      DCL state               SBIN;
      353      106    1      DCL string_index        UBIN;
      354      107    1      DCL 1 tempstr,
PL6.E3A0      #006=STRTOD File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:29   
      355      108    1            2 length          SBIN,
      356      109    1            2 text            CHAR (%tempstr_size);
      357      110    1      DCL type                UBIN;
      358      111    1      DCL void_tv             UBIN;
      359      112
      360      113           %EQU error_state     = -2;
      361      114           %EQU finish_state    = -1;
      362      115    1      DCL transition_table (0 : 39) SBIN WORD CONSTANT INIT (
      363      116    1            /*  0: */   10,   15,            %error_state,  5,             %error_state
               116                     ,
      364      117    1            /*  5: */   10,   15,            %error_state,  %error_state,  %error_state
               117                     ,
      365      118    1            /* 10: */   10,   20,            25,            %finish_state, %
               118                     finish_state,
      366      119    1            /* 15: */   20,   %error_state,  %error_state,  %error_state,  %error_state
               119                     ,
      367      120    1            /* 20: */   20,   %finish_state, 25,            %finish_state, %
               120                     finish_state,
      368      121    1            /* 25: */   35,   %error_state,  %error_state,  30,            %error_state
               121                     ,
      369      122    1            /* 30: */   35,   %error_state,  %error_state,  %error_state,  %error_state
               122                     ,
      370      123    1            /* 35: */   35,   %finish_state, %finish_state, %finish_state, %
               123                     finish_state);
      371      124
      372      125
      373      126              /* these values correspond to the characters in 'characters' */
      374      127    1      DCL character_class (0 : 16)  SBIN WORD CONSTANT INIT
      375      128    1            (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 3, 3, 4);
      376      129
      377      130    1      DCL characters CHAR (15) CONSTANT INIT
      378      131    1            ('0123456789.Ee+-');
      379      132
      380      133    1      DCL XBI$STRING_TO_REAL         ENTRY (3);
      381      134    1      DCL XB_RETURN_REAL_RESULT      ENTRY (1);
      382      135    1      DCL XBI_SET_ERRNO              ENTRY (1);
      383      136    1      DCL XBI$STRLEN                 ENTRY (2);
PL6.E3A0      #006=STRTOD File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:30   
      384      137
      385      138    1      DCL double_zero BIT(72) DALIGNED CONSTANT INIT('100000000000000000000000'O);
      386      139
      387      140
      388      141
      389      142    1   dont_set_errno = '0'B;
      390      143    1   GOTO Start_of_code;
      391      144
      392      145    1   atof: ENTRY (string);
      393      146
      394      147        /*D* PROTOTYPE:   double atof (char *str);
      395      148             DESCRIPTION: atof converts a string to a number. Any leading
      396      149                          whitespace is skipped and then a number can consist
      397      150                          of an optional plus or minus sign, a sequence of
      398      151                          decimal digits (possible containing a single decimal
      399      152                          point) and an optional exponent part consisting of the
      400      153                          letter e or E, an optional sign and a sequence of
      401      154                          decimal digits. The value returned is converted from
      402      155                          the longest sequence that matches this model.
      403      156        */
      404      157
      405      158
      406      159    1   dont_set_errno = '1'B;
      407      160
      408      161    1   Start_of_code:
      409      162
      410      163    1      CALL XBI$STRLEN (string, string_len);
      411      164
      412      165    1      CALL SEARCH (string_index, void_tv, XBI$non_whitespace_table, string);
      413      166    1      start_index = string_index;
      414      167    1      state = 0;
      415      168    1      IF SUBSTR (string, string_index, 1) = '-' THEN
      416      169    1         negative_value = '1'B;
      417      170    1      ELSE
      418      171    1         negative_value = '0'B;
      419      172    2      DO WHILE '1'B;
      420      173    2         CALL INDEX1 (type, SUBSTR(string, string_index, 1), characters);
PL6.E3A0      #006=STRTOD File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:31   
      421      174    2         state = transition_table(state + character_class(type));
      422      175    2         chunk_length = string_index - start_index;
      423      176    3         IF state = %finish_state THEN DO;
      424      177    4            IF chunk_length > %tempstr_size THEN DO;
      425      178    4               IF (~dont_set_errno) THEN
      426      179    4                  CALL XBI_SET_ERRNO (ERR$BAD_OR_MISSING_REAL_NUMBER);
      427      180    4               GOTO error_return;
      428      181    4            END;
      429      182    3            SUBSTR (tempstr.text, 0, chunk_length) = SUBSTR (string,
      430      183    3               start_index, chunk_length);
      431      184    3            tempstr.length = chunk_length;
      432      185    3            GOTO found_end;
      433      186    3         END;
      434      187    3         IF state = %error_state THEN DO;
      435      188    3            IF (~dont_set_errno) THEN
      436      189    3               CALL XBI_SET_ERRNO (ERR$BAD_OR_MISSING_REAL_NUMBER);
      437      190    3            GOTO error_return;
      438      191    3         END;
      439      192    2         string_index = string_index + 1;
      440      193    2      END; /* while */
      441      194
      442      195    1   found_end:
      443      196    1      IF ADDR(sub) ~= ADDR(NIL) THEN
      444      197    1         sub = ADDR(SUBSTR (string, string_index, 1));
      445      198    1      CALL XBI$STRING_TO_REAL (tempstr, result, overflow_error);
      446      199    1      IF (overflow_error) AND (~dont_set_errno) THEN
      447      200    1         CALL XBI_SET_ERRNO (ERR$RANGE_ERROR);
      448      201    1      CALL XB_RETURN_REAL_RESULT (result);
      449      202
      450      203    1   error_return:
      451      204    1      IF ADDR(sub) ~= ADDR(NIL) THEN
      452      205    1         sub = ADDR(string);
      453      206    1      CALL XB_RETURN_REAL_RESULT (double_zero);
      454      207    1   END strtod;
      455      208        %EOD;

PL6.E3A0      #006=STRTOD File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:32   
--  Include file information  --

   xb_errors_i6.:XBC3TOU  cannot be made into a system file and is referenced.
      No diagnostics issued in procedure STRTOD.

   Procedure STRTOD requires 133 words for executable code.
   Procedure STRTOD requires 72 words of local(AUTO) storage.

PL6.E3A0      #006=STRTOD File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:33   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #006=STRTOD File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:34   
          MINI XREF LISTING

CHARACTERS
       130**DCL       173>>CALLBLT
CHARACTER_CLASS
       127**DCL       174>>ASSIGN
CHUNK_LENGTH
        99**DCL       175<<ASSIGN    177>>IF        182>>ASSIGN    182>>ASSIGN    184>>ASSIGN
DONT_SET_ERRNO
       103**DCL       142<<ASSIGN    159<<ASSIGN    178>>IF        188>>IF        199>>IF
DOUBLE_ZERO
       138**DCL       206<>CALL
ERROR_RETURN
       204**LABEL     180--GOTO      190--GOTO
FOUND_END
       196**LABEL     185--GOTO
NEGATIVE_VALUE
       100**DCL       169<<ASSIGN    171<<ASSIGN
OVERFLOW_ERROR
       102**DCL       198<>CALL      199>>IF
RESULT
        96**DCL       198<>CALL      201<>CALL
START_INDEX
       104**DCL       166<<ASSIGN    175>>ASSIGN    182>>ASSIGN
START_OF_CODE
       163**LABEL     143--GOTO
STATE
       105**DCL       167<<ASSIGN    174<<ASSIGN    174>>ASSIGN    176>>IF        187>>IF
STRING
        92**DCL         7--PROC      145--ENTRY     163<>CALL      165>>CALLBLT   168>>IF        173>>CALLBLT
       182>>ASSIGN    197--ASSIGN    205--ASSIGN
STRING_INDEX
       106**DCL       165<<CALLBLT   166>>ASSIGN    168>>IF        173>>CALLBLT   175>>ASSIGN    192<<ASSIGN
       192>>ASSIGN    197>>ASSIGN
PL6.E3A0      #006=STRTOD File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:35   
STRING_LEN
        93**DCL        92--IMP-SIZ   163>>CALL      163<>CALL      165>>CALLBLT   168>>IF        173>>CALLBLT
       182>>ASSIGN    197>>ASSIGN
SUB
        94**DCL         7--PROC      196--IF        197<<ASSIGN    204--IF        205<<ASSIGN
TEMPSTR
       107**DCL       198<>CALL
TEMPSTR.LENGTH
       108**DCL       184<<ASSIGN
TEMPSTR.TEXT
       109**DCL       182<<ASSIGN
TRANSITION_TABLE
       115**DCL       174>>ASSIGN
TYPE
       110**DCL       173<<CALLBLT   174>>ASSIGN
VOID_TV
       111**DCL       165<<CALLBLT
XB$ERR$BAD_OR_MISSING_REAL_NUM
        61**DCL       179<>CALL      189<>CALL
XB$ERR$RANGE_ERROR
        73**DCL       200<>CALL
XBI$NON_WHITESPACE_TABLE
       101**DCL       165>>CALLBLT
XBI$STRING_TO_REAL
       133**DCL-ENT   198--CALL
XBI$STRLEN
       136**DCL-ENT   163--CALL
XBI_SET_ERRNO
       135**DCL-ENT   179--CALL      189--CALL      200--CALL
XB_RETURN_REAL_RESULT
       134**DCL-ENT   201--CALL      206--CALL

PL6.E3A0      #007=STRTOL File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:36   
      456        1        /*T***********************************************************/
      457        2        /*T*                                                         */
      458        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
      459        4        /*T*                                                         */
      460        5        /*T***********************************************************/
      461        6
      462        7        strtol: PROC (string, sub, base_value);
      463        8
      464        9        /*D* PROTOTYPE:   long strtol (char *str, **ptr, int base);
      465       10             DESCRIPTION: strtol converts a string to a number. Any leading
      466       11                          whitespace is skipped and then a number can consist
      467       12                          of an optional plus or minus sign, a sequence of
      468       13                          digits. The values the digits can take on changes
      469       14                          with the value of base. If base is zero then the number
      470       15                          can be decimal, octal or hexadecimal and the format of
      471       16                          the string controls which.
      472       17                          The value returned is converted from the longest
      473       18                          sequence that matches this model. If ptr is not null
      474       19                          then on return it points to the character just past
      475       20                          the last character used in the conversion.
      476       21             RAP Oct 10, 1988
      477       22             JAS Dec 1, 1988    -hacked for performance and more error checking.
      478       23        */
      479       24
      480       25        %INCLUDE xb_errors_i6;
      481       96        %INCLUDE B$TABLES_C;
      482      204
      483      205    1   DCL string              CHAR (string_len);
      484      206    1   DCL string_len          SBIN;
      485      207    1   DCL sub PTR;
      486      208    1   DCL base_value SBIN WORD;
      487      209    1   DCL funny_ptr PTR;
      488      210    1   DCL base REDEF funny_ptr SBIN;
      489      211
      490      212    1   DCL string_index SBIN WORD ALIGNED;
      491      213    1   DCL string_length SBIN WORD ALIGNED;
      492      214    1   DCL neg_result SBIN ALIGNED;
PL6.E3A0      #007=STRTOL File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:37   
      493      215        %B$SR_NON_DEC (NAME=XBI$non_digit_table);
      494      219    1   DCL temp_char CHAR(1) ALIGNED;
      495      220    1   DCL temp_str CHAR(2) ALIGNED;
      496      221    1   DCL ord_char UBIN WORD;
      497      222    1   DCL temp_int UBIN WORD;
      498      223        %EQU white_tv = 0;
      499      224        %EQU other_tv = 1;
      500      225        %EQU plus_tv  = 2;
      501      226        %EQU minus_tv = 3;
      502      227        %EQU digit_tv = 5;
      503      228        %EQU letter_tv = 6;
      504      229    1   DCL search_table (0:511) UBIN BYTE UNAL CONSTANT INIT (
      505      230    1      %other_tv*9,
      506      231    1      %white_tv*5,
      507      232    1      %other_tv*18,
      508      233    1      %white_tv,
      509      234    1      %other_tv*10,
      510      235    1      %plus_tv,
      511      236    1      %other_tv,
      512      237    1      %minus_tv,
      513      238    1      %other_tv*2,
      514      239    1      %digit_tv*10,
      515      240    1      %other_tv*7,
      516      241    1      %letter_tv*26,
      517      242    1      %other_tv*6,
      518      243    1      %letter_tv*26,
      519      244    1      %other_tv*389);
      520      245    1   DCL start                     UBIN;
      521      246    1   DCL table_value               UBIN;
      522      247    1   DCL XBI$digit_value_table (0:127) UBIN WORD SYMREF READONLY;
      523      248    1   DCL first_digit_index         UBIN;
      524      249    1   DCL overflow                  SBIN;
      525      250    1   DCL dont_set_errno            BIT(1)   ALIGNED;
      526      251
      527      252    1   DCL XB_RETURN_ORDINAL_RESULT  ENTRY (1);
      528      253    1   DCL XPN_7NS0TOI ENTRY(3) ALTRET;
      529      254    1   DCL XPN_7LS0TOI ENTRY(3) ALTRET;
PL6.E3A0      #007=STRTOL File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:38   
      530      255    1   DCL XBI_SET_ERRNO ENTRY(1);
      531      256    1   DCL XB_IO_ERROR ENTRY;
      532      257    1   DCL XBI$STRLEN  ENTRY(2);
      533      258
      534      259    1   DCL POS_INFINITY BIT(36) ALIGNED CONSTANT INIT('377777777777'O);
      535      260    1   DCL NEG_INFINITY BIT(36) ALIGNED CONSTANT INIT('400000000000'O);
      536      261
      537      262    1   DCL RESULT SBIN WORD ALIGNED;
      538      263    1   DCL val    UBIN;
      539      264    1   DCL oldval UBIN;
      540      265
      541      266    1   funny_ptr = ADDR(base_value);      /* this gets the real value of base */
      542      267
      543      268    2   IF NOT (base = 0 OR (base >= 2 AND base <= 36)) THEN DO;
      544      269    2      CALL XBI_SET_ERRNO (ERR$BAD_BASE);
      545      270    2      GOTO error_return;
      546      271    2   END;
      547      272
      548      273    1   dont_set_errno = '0'B;
      549      274    1   GOTO Start_of_code;
      550      275
      551      276    1   atoi: ENTRY (string);
      552      277
      553      278        /*D* PROTOTYPE:   int atoi (char *str);
      554      279             DESCRIPTION: atoi converts a string to a number. Any leading
      555      280                          whitespace is skipped and then a number can consist
      556      281                          of an optional plus or minus sign, a sequence of
      557      282                          digits. The value returned is converted from the
      558      283                          longest sequence that matches this model.
      559      284             RAP Oct 11, 1988
      560      285        */
      561      286
      562      287    1   atol: ENTRY(string);
      563      288
      564      289        /*D* PROTOTYPE:   long atol (char *str);
      565      290             DESCRIPTION: atol converts a string to a number. Any leading
      566      291                          whitespace is skipped and then a number can consist
PL6.E3A0      #007=STRTOL File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:39   
      567      292                          of an optional plus or minus sign, a sequence of
      568      293                          digits. The value returned is converted from the
      569      294                          longest sequence that matches this model.
      570      295             RAP Oct 11, 1988
      571      296        */
      572      297
      573      298    1   base = 10;
      574      299    1   dont_set_errno = '1'B;
      575      300
      576      301    1   Start_of_code:
      577      302
      578      303    1      CALL XBI$STRLEN (string, string_len);
      579      304    1      string_len = string_len + 1;
      580      305    1   CALL SEARCH (string_index, table_value, search_table, string, 0)
      581      306    2      WHENALTRETURN DO;
      582      307    2         IF (~dont_set_errno) THEN
      583      308    2            CALL XBI_SET_ERRNO (ERR$STRING_TOO_LONG);
      584      309    2         GOTO error_return;
      585      310    2      END;
      586      311    1   neg_result = 1;
      587      312    2   DO CASE (table_value);
      588      313    2      CASE (%other_tv);
      589      314    2         IF (~dont_set_errno) THEN
      590      315    2            CALL XBI_SET_ERRNO (ERR$SCAN_MISMATCH);
      591      316    2         GOTO error_return;
      592      317    2      CASE (%plus_tv);
      593      318    2         string_index = string_index + 1;
      594      319    2      CASE (%minus_tv);
      595      320    2         neg_result = -1;
      596      321    2         string_index = string_index + 1;
      597      322    2      CASE (%digit_tv, %letter_tv);
      598      323    2      CASE (ELSE);
      599      324    2         CALL XBI_SET_ERRNO (ERR$ASSERTION_FAILURE);
      600      325    2         CALL XB_IO_ERROR;
      601      326    2   END;
      602      327
      603      328    1   temp_str = SUBSTR(string, string_index, 2);
PL6.E3A0      #007=STRTOL File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:40   
      604      329    1   IF  base=16  AND                  /* he says hex .. get rid of 0x */
      605      330    1      (temp_str = '0x'  OR  temp_str = '0X')
      606      331    1        THEN  string_index = string_index + 2;
      607      332
      608      333    2   IF (base=0) THEN DO;              /* determine format */
      609      334    3      IF SUBSTR (temp_str, 0, 1) = '0' THEN DO;    /* still cant tell  */
      610      335    3         temp_char = SUBSTR(temp_str, 1, 1);
      611      336    4         IF (temp_char='x') OR (temp_char='X') THEN DO;
      612      337    4            base = 16;
      613      338    4            string_index = string_index + 2;  /* absorb the X */
      614      339    4            END;
      615      340    3         ELSE base = 8;
      616      341    3         END;
      617      342    2      ELSE base = 10;
      618      343    2      END;
      619      344
      620      345    1   result = 0;
      621      346    2   IF (base = 10) THEN DO;
      622      347    2      start = string_index;
      623      348    2      CALL SEARCH (string_index, table_value, XBI$non_digit_table, string, string_index
               348               )
      624      349    3         WHENALTRETURN DO;
      625      350    3            IF (~dont_set_errno) THEN
      626      351    3               CALL XBI_SET_ERRNO (ERR$STRING_TOO_LONG);
      627      352    3            GOTO error_return;
      628      353    3         END;
      629      354    2      string_length = string_index - start;
      630      355    3      IF (string_length=0) THEN DO;
      631      356    3         IF (~dont_set_errno) THEN
      632      357    3            CALL XBI_SET_ERRNO (ERR$SCAN_MISMATCH);
      633      358    3         GOTO error_return;
      634      359    3      END;
      635      360    3      IF (neg_result< 0) THEN DO;
      636      361    3         CALL XPN_7LS0TOI(RESULT,SUBSTR (string, start-1, 1),string_length)
      637      362    3            ALTRET (overflow_return);
      638      363    3         neg_result = 0;
      639      364    3      END;
PL6.E3A0      #007=STRTOL File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:41   
      640      365    2      ELSE
      641      366    2         CALL XPN_7NS0TOI(RESULT,SUBSTR (string, start, 1),string_length)
      642      367    2            ALTRET (overflow_return);
      643      368    2      GOTO normal_return;
      644      369    2   END; ELSE DO;
      645      370
      646      371           /* handle all other cases */
      647      372
      648      373    2      first_digit_index = string_index;
      649      374    2      overflow = 0;
      650      375    2      oldval = 0;  val = 0;
      651      376    3      DO WHILE('1'B);
      652      377    3         ord_char = ASCBIN (SUBSTR(string,string_index,1));
      653      378    3         IF ord_char > 127 THEN   EXIT;
      654      379    3         temp_int = XBI$digit_value_table (ord_char);
      655      380    3         IF temp_int >= base THEN  EXIT;
      656      381                 /* this is a legal digit for this base */
      657      382    3         string_index = string_index + 1;
      658      383    3         val = val*base + temp_int;
      659      384    3         if (oldval > 0  and  val <= oldval)
      660      385    3            THEN overflow = overflow + 1;
      661      386    3         oldval = val;
      662      387    3      END;       /*  of   "while"     */
      663      388    2      result = val;
      664      389    3      IF (overflow = 0 AND result < 0) THEN DO;
      665      390    3         IF (neg_result < 0 AND result = BITBIN(NEG_INFINITY))
      666      391    3            THEN neg_result = 0;
      667      392    3            ELSE overflow   = overflow + 1;
      668      393    3      END;
      669      394    2      IF string_index = first_digit_index THEN GOTO error_return;
      670      395    2      IF (overflow > 0) THEN GOTO overflow_return;
      671      396    2      GOTO normal_return;
      672      397    2   END;
      673      398
      674      399    1   error_return:
      675      400    1      IF NOT ADDR(sub) = ADDR(NIL) THEN sub = ADDR(string);
      676      401    1      CALL XB_RETURN_ORDINAL_RESULT (0);
PL6.E3A0      #007=STRTOL File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:42   
      677      402
      678      403    1   overflow_return:
      679      404    1      IF NOT(ADDR(sub)=ADDR(NIL)) THEN sub = ADDR(SUBSTR(string,string_index,1));
      680      405    1      IF (~dont_set_errno) THEN
      681      406    1         CALL XBI_SET_ERRNO(ERR$RANGE_ERROR);  /* set ERRNO to a range error */
      682      407    1      IF neg_result < 0
      683      408    1         THEN CALL XB_RETURN_ORDINAL_RESULT ( NEG_INFINITY );
      684      409    1         ELSE CALL XB_RETURN_ORDINAL_RESULT ( POS_INFINITY );
      685      410
      686      411    1   normal_return:
      687      412    1      IF NOT(ADDR(sub)=ADDR(NIL)) THEN sub = ADDR(SUBSTR(string,string_index,1));
      688      413    1      IF neg_result < 0 THEN   RESULT = - RESULT;
      689      414    1      CALL XB_RETURN_ORDINAL_RESULT ( RESULT );
      690      415    1   END strtol;
      691      416        %EOD;

PL6.E3A0      #007=STRTOL File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:43   
--  Include file information  --

   B$TABLES_C.:LIB_E04  cannot be made into a system file and is referenced.
   xb_errors_i6.:XBC3TOU  cannot be made into a system file and is referenced.
      No diagnostics issued in procedure STRTOL.

   Procedure STRTOL requires 320 words for executable code.
   Procedure STRTOL requires 28 words of local(AUTO) storage.

PL6.E3A0      #007=STRTOL File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:44   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #007=STRTOL File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:45   
          MINI XREF LISTING

B$SR_NON_DEC$
       216**DCL       217--IMP-PTR   348>>CALLBLT
BASE
       210**DCL       268>>IF        268>>IF        268>>IF        298<<ASSIGN    329>>IF        333>>IF
       337<<ASSIGN    340<<ASSIGN    342<<ASSIGN    346>>IF        380>>IF        383>>ASSIGN
BASE_VALUE
       208**DCL         7--PROC      266--ASSIGN
DONT_SET_ERRNO
       250**DCL       273<<ASSIGN    299<<ASSIGN    307>>IF        314>>IF        350>>IF        356>>IF
       405>>IF
ERROR_RETURN
       400**LABEL     270--GOTO      309--GOTO      316--GOTO      352--GOTO      358--GOTO      394--GOTO
FIRST_DIGIT_INDEX
       248**DCL       373<<ASSIGN    394>>IF
FUNNY_PTR
       209**DCL       210--REDEF     266<<ASSIGN
NEG_INFINITY
       260**DCL       390>>IF        408<>CALL
NEG_RESULT
       214**DCL       311<<ASSIGN    320<<ASSIGN    360>>IF        363<<ASSIGN    390>>IF        391<<ASSIGN
       407>>IF        413>>IF
NORMAL_RETURN
       412**LABEL     368--GOTO      396--GOTO
OLDVAL
       264**DCL       375<<ASSIGN    384>>IF        384>>IF        386<<ASSIGN
ORD_CHAR
       221**DCL       377<<ASSIGN    378>>IF        379>>ASSIGN
OVERFLOW
       249**DCL       374<<ASSIGN    385<<ASSIGN    385>>ASSIGN    389>>IF        392<<ASSIGN    392>>ASSIGN
       395>>IF
OVERFLOW_RETURN
       404**LABEL     361--CALLALT   366--CALLALT   395--GOTO
PL6.E3A0      #007=STRTOL File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:46   
POS_INFINITY
       259**DCL       409<>CALL
RESULT
       262**DCL       345<<ASSIGN    361<>CALL      366<>CALL      388<<ASSIGN    389>>IF        390>>IF
       413<<ASSIGN    413>>ASSIGN    414<>CALL
SEARCH_TABLE
       229**DCL       305>>CALLBLT
START
       245**DCL       347<<ASSIGN    354>>ASSIGN    361>>CALL      366>>CALL
START_OF_CODE
       303**LABEL     274--GOTO
STRING
       205**DCL         7--PROC      276--ENTRY     287--ENTRY     303<>CALL      305>>CALLBLT   328>>ASSIGN
       348>>CALLBLT   361<>CALL      366<>CALL      377>>ASSIGN    400--ASSIGN    404--ASSIGN    412--ASSIGN
STRING_INDEX
       212**DCL       305<<CALLBLT   318<<ASSIGN    318>>ASSIGN    321<<ASSIGN    321>>ASSIGN    328>>ASSIGN
       331<<ASSIGN    331>>ASSIGN    338<<ASSIGN    338>>ASSIGN    347>>ASSIGN    348<<CALLBLT   348>>CALLBLT
       354>>ASSIGN    373>>ASSIGN    377>>ASSIGN    382<<ASSIGN    382>>ASSIGN    394>>IF        404>>ASSIGN
       412>>ASSIGN
STRING_LEN
       206**DCL       205--IMP-SIZ   303>>CALL      303<>CALL      304<<ASSIGN    304>>ASSIGN    305>>CALLBLT
       328>>ASSIGN    348>>CALLBLT   361>>CALL      366>>CALL      377>>ASSIGN    404>>ASSIGN    412>>ASSIGN
STRING_LENGTH
       213**DCL       354<<ASSIGN    355>>IF        361<>CALL      366<>CALL
SUB
       207**DCL         7--PROC      400--IF        400<<ASSIGN    404--IF        404<<ASSIGN    412--IF
       412<<ASSIGN
TABLE_VALUE
       246**DCL       305<<CALLBLT   312>>DOCASE    348<<CALLBLT
TEMP_CHAR
       219**DCL       335<<ASSIGN    336>>IF        336>>IF
TEMP_INT
       222**DCL       379<<ASSIGN    380>>IF        383>>ASSIGN
TEMP_STR
       220**DCL       328<<ASSIGN    329>>IF        329>>IF        334>>IF        335>>ASSIGN
VAL
PL6.E3A0      #007=STRTOL File=xb_stdlib:6.:XBC3TSI                              FRI 01/06/95 11:23 Page:47   
       263**DCL       375<<ASSIGN    383<<ASSIGN    383>>ASSIGN    384>>IF        386>>ASSIGN    388>>ASSIGN
XB$ERR$ASSERTION_FAILURE
        70**DCL       324<>CALL
XB$ERR$BAD_BASE
        67**DCL       269<>CALL
XB$ERR$RANGE_ERROR
        78**DCL       406<>CALL
XB$ERR$SCAN_MISMATCH
        84**DCL       315<>CALL      357<>CALL
XB$ERR$STRING_TOO_LONG
        82**DCL       308<>CALL      351<>CALL
XBI$DIGIT_VALUE_TABLE
       247**DCL       379>>ASSIGN
XBI$NON_DIGIT_TABLE
       217**DCL       348>>CALLBLT
XBI$STRLEN
       257**DCL-ENT   303--CALL
XBI_SET_ERRNO
       255**DCL-ENT   269--CALL      308--CALL      315--CALL      324--CALL      351--CALL      357--CALL
       406--CALL
XB_IO_ERROR
       256**DCL-ENT   325--CALL
XB_RETURN_ORDINAL_RESULT
       252**DCL-ENT   401--CALL      408--CALL      409--CALL      414--CALL
XPN_7LS0TOI
       254**DCL-ENT   361--CALL
XPN_7NS0TOI
       253**DCL-ENT   366--CALL

PL6.E3A0      #008=STRTOUL File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:48   
      692        1        /*T***********************************************************/
      693        2        /*T*                                                         */
      694        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
      695        4        /*T*                                                         */
      696        5        /*T***********************************************************/
      697        6
      698        7        strtoul: PROC (string, sub, base_value);
      699        8
      700        9        /*D* PROTOTYPE:   unsigned long strtoul (char *str, **ptr, int base);
      701       10             DESCRIPTION: strtoul converts a string to a number. Any leading
      702       11                          whitespace is skipped and then a number can consist
      703       12                          a sequence of digits. The values the digits can take
      704       13                          on changes with the value of base. If base is zero
      705       14                          then the number can be decimal, octal or hexadecimal
      706       15                          and the format of the string controls which.
      707       16                          The value returned is converted from the longest
      708       17                          sequence that matches this model. If ptr is not null
      709       18                          then on return it points to the character just past
      710       19                          the last character used in the conversion.
      711       20
      712       21        */
      713       22
      714       23        %INCLUDE xb_errors_i6;
      715       94        %INCLUDE B$TABLES_C;
      716      202
      717      203    1   DCL string              CHAR (string_len);
      718      204    1   DCL string_len          SBIN;
      719      205    1   DCL sub PTR;
      720      206    1   DCL base_value SBIN WORD;
      721      207    1   DCL funny_ptr PTR;
      722      208    1   DCL base REDEF funny_ptr UBIN;
      723      209
      724      210    1   DCL string_index UBIN WORD ALIGNED;
      725      211    1   DCL string_length UBIN WORD ALIGNED;
      726      212    1   DCL temp_char CHAR(1) ALIGNED;
      727      213    1   DCL ord_char UBIN WORD;
      728      214    1   DCL temp_int UBIN WORD;
PL6.E3A0      #008=STRTOUL File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:49   
      729      215        %EQU white_tv = 0;
      730      216        %EQU other_tv = 1;
      731      217        %EQU plus_tv  = 2;
      732      218        %EQU minus_tv = 3;
      733      219        %EQU digit_tv = 5;
      734      220        %EQU letter_tv = 6;
      735      221    1   DCL search_table (0:511) UBIN BYTE UNAL CONSTANT INIT (
      736      222    1      %other_tv*9,
      737      223    1      %white_tv*5,
      738      224    1      %other_tv*18,
      739      225    1      %white_tv,
      740      226    1      %other_tv*10,
      741      227    1      %plus_tv,
      742      228    1      %other_tv,
      743      229    1      %minus_tv,
      744      230    1      %other_tv*2,
      745      231    1      %digit_tv*10,
      746      232    1      %other_tv*7,
      747      233    1      %letter_tv*26,
      748      234    1      %other_tv*6,
      749      235    1      %letter_tv*26,
      750      236    1      %other_tv*389);
      751      237    1   DCL start                     UBIN;
      752      238    1   DCL table_value               UBIN;
      753      239    1   DCL XBI$digit_value_table (0:127) UBIN WORD SYMREF READONLY;
      754      240        %B$SR_NON_DEC (NAME=XBI$non_digit_table);
      755      244    1   DCL first_digit_index         UBIN;
      756      245    1   DCL overflow                  SBIN;
      757      246    1   DCL temp_ubin                 UBIN;
      758      247
      759      248    1   DCL XB_RETURN_ORDINAL_RESULT  ENTRY (1);
      760      249    1   DCL XPN_7NS0TOU ENTRY(3) ALTRET;
      761      250    1   DCL XPN_7LS0TOU ENTRY(3) ALTRET;
      762      251    1   DCL XBI_SET_ERRNO ENTRY(1);
      763      252    1   DCL XB_IO_ERROR ENTRY;
      764      253    1   DCL XBI$STRLEN  ENTRY(2);
      765      254
PL6.E3A0      #008=STRTOUL File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:50   
      766      255    1   DCL POS_INFINITY BIT(36) ALIGNED CONSTANT INIT('777777777777'O);
      767      256    1   DCL UBIN_INFINITY REDEF POS_INFINITY UBIN;
      768      257
      769      258    1   DCL RESULT UBIN WORD ALIGNED;
      770      259    1   DCL neg_result SBIN     ALIGNED;
      771      260    1   DCL temp_str   CHAR(2);
      772      261    1   DCL val        UBIN;
      773      262    1   DCL oldval     UBIN;
      774      263
      775      264    1   funny_ptr = ADDR(base_value);      /* this gets the real value of base */
      776      265
      777      266    1   CALL XBI$STRLEN (string, string_len);
      778      267    1   string_len = string_len + 1;
      779      268
      780      269    2   IF NOT (base = 0 OR (base >= 2 AND base <= 36)) THEN DO;
      781      270    2      CALL XBI_SET_ERRNO (ERR$BAD_BASE);
      782      271    2      GOTO error_return;
      783      272    2   END;
      784      273
      785      274    1   CALL SEARCH (string_index, table_value, search_table, string, 0)
      786      275    2      WHENALTRETURN DO;
      787      276    2         CALL XBI_SET_ERRNO (ERR$STRING_TOO_LONG);
      788      277    2         GOTO error_return;
      789      278    2      END;
      790      279    1   neg_result = 0;
      791      280    2   DO CASE (table_value);
      792      281    2      CASE (%other_tv);
      793      282    2         CALL XBI_SET_ERRNO (ERR$SCAN_MISMATCH);
      794      283    2         GOTO error_return;
      795      284    2      CASE (%plus_tv);
      796      285    2         string_index = string_index + 1;
      797      286    2      CASE (%minus_tv);
      798      287    2         neg_result = -1;
      799      288    2         string_index = string_index + 1;
      800      289    2      CASE (%digit_tv, %letter_tv);
      801      290    2      CASE (ELSE);
      802      291    2         CALL XBI_SET_ERRNO (ERR$ASSERTION_FAILURE);
PL6.E3A0      #008=STRTOUL File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:51   
      803      292    2         CALL XB_IO_ERROR;
      804      293    2   END;
      805      294
      806      295    1   temp_str = SUBSTR(string, string_index, 2);
      807      296    1   IF (base=16) AND       /* if hex, ignore 0x   */
      808      297    1      (temp_str = '0x'  or  temp_str = '0X')
      809      298    1      THEN  string_index = string_index + 2;
      810      299
      811      300    2   IF (base=0) THEN DO;              /* determine format */
      812      301    3      IF SUBSTR (temp_str, 0, 1) = '0' THEN DO;    /* still cant tell  */
      813      302    3         temp_char = SUBSTR(temp_str, 1, 1);
      814      303    4         IF (temp_char='x') OR (temp_char='X') THEN DO;
      815      304    4            base = 16;
      816      305    4            string_index = string_index + 2;  /* absorb the X */
      817      306    4            END;
      818      307    3         ELSE base = 8;
      819      308    3         END;
      820      309    2      ELSE base = 10;
      821      310    2      END;
      822      311
      823      312    1   result = 0;
      824      313    1   first_digit_index = string_index;
      825      314    1   start             = first_digit_index;
      826      315    1   overflow = 0;
      827      316
      828      317    2   IF (base = 10)  THEN DO;
      829      318    2      CALL SEARCH(string_index, temp_ubin, XBI$non_digit_table, STRING, start)
      830      319    3         WHENALTRETURN DO;
      831      320    3            CALL XBI_SET_ERRNO(ERR$STRING_TOO_LONG);
      832      321    3            GOTO error_return;
      833      322    3         END;
      834      323
      835      324    2      string_length  = string_index - start;
      836      325    3      IF (string_length = 0) THEN DO;
      837      326    3         CALL XBI_SET_ERRNO(ERR$SCAN_MISMATCH);
      838      327    3         GOTO error_return;
      839      328    3      END;
PL6.E3A0      #008=STRTOUL File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:52   
      840      329
      841      330    3      IF (neg_result < 0) THEN DO;
      842      331    3         CALL XPN_7LS0TOU(RESULT, SUBSTR(string,start-1,1), string_length)
      843      332    3            ALTRET(overflow_return);
      844      333    3         neg_result = 0;
      845      334    3         END;
      846      335    2      ELSE CALL XPN_7NS0TOU(RESULT,SUBSTR(string,start,1),string_length)
      847      336    2         ALTRET(overflow_return);
      848      337
      849      338    2      GOTO normal_return;
      850      339    2      END;
      851      340
      852      341    2   ELSE DO;
      853      342
      854      343    2      oldval = 0;
      855      344    2      val    = 0;
      856      345    3      DO WHILE('1'B);
      857      346    3         ord_char = ASCBIN (SUBSTR(string,string_index,1));
      858      347    3         IF ord_char > 127 THEN EXIT;
      859      348    3         temp_int = XBI$digit_value_table (ord_char);
      860      349    3         IF temp_int >= base THEN EXIT;
      861      350              /* this is a legal digit for this base */
      862      351    3         string_index = string_index + 1;
      863      352    3         val = val*base + temp_int;
      864      353    3         IF (oldval > 0 AND val <= oldval)
      865      354    3            THEN overflow = overflow + 1;
      866      355    3         oldval = val;
      867      356    3      END;
      868      357
      869      358    2      result = val;
      870      359    3      IF (overflow = 0 AND result > BITBIN('377777777777'O) AND neg_result < 0) THEN DO
               359               ;
      871      360    3         IF (result = BITBIN('400000000000'O))
      872      361    3            THEN neg_result = 0;
      873      362    3            ELSE overflow   = overflow + 1;
      874      363    3      END;
      875      364    2      IF string_index = first_digit_index THEN GOTO error_return;
PL6.E3A0      #008=STRTOUL File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:53   
      876      365    2      IF (overflow > 0) THEN GOTO overflow_return;
      877      366    2      GOTO normal_return;
      878      367    2   END;
      879      368
      880      369    1   error_return:
      881      370    1      IF NOT ADDR(sub) = ADDR(NIL) THEN sub = ADDR(string);
      882      371    1      CALL XB_RETURN_ORDINAL_RESULT (0);
      883      372
      884      373    1   overflow_return:
      885      374    1      IF NOT(ADDR(sub)=ADDR(NIL)) THEN sub = ADDR(SUBSTR(string,string_index,1));
      886      375    1      CALL XBI_SET_ERRNO(ERR$RANGE_ERROR);  /* set ERRNO to a range error */
      887      376    1      CALL XB_RETURN_ORDINAL_RESULT ( POS_INFINITY );
      888      377
      889      378    1   normal_return:
      890      379    1      IF NOT(ADDR(sub)=ADDR(NIL)) THEN sub = ADDR(SUBSTR(string,string_index,1));
      891      380    1      IF neg_result < 0  THEN RESULT =  0 - RESULT;
      892      381    1      CALL XB_RETURN_ORDINAL_RESULT ( RESULT );
      893      382    1   END strtoul;
      894      383        %EOD;

PL6.E3A0      #008=STRTOUL File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:54   
--  Include file information  --

   B$TABLES_C.:LIB_E04  cannot be made into a system file and is referenced.
   xb_errors_i6.:XBC3TOU  cannot be made into a system file and is referenced.
      No diagnostics issued in procedure STRTOUL.

   Procedure STRTOUL requires 284 words for executable code.
   Procedure STRTOUL requires 28 words of local(AUTO) storage.

PL6.E3A0      #008=STRTOUL File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:55   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #008=STRTOUL File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:56   
          MINI XREF LISTING

B$SR_NON_DEC$
       241**DCL       242--IMP-PTR   318>>CALLBLT
BASE
       208**DCL       269>>IF        269>>IF        269>>IF        296>>IF        300>>IF        304<<ASSIGN
       307<<ASSIGN    309<<ASSIGN    317>>IF        349>>IF        352>>ASSIGN
BASE_VALUE
       206**DCL         7--PROC      264--ASSIGN
ERROR_RETURN
       370**LABEL     271--GOTO      277--GOTO      283--GOTO      321--GOTO      327--GOTO      364--GOTO
FIRST_DIGIT_INDEX
       244**DCL       313<<ASSIGN    314>>ASSIGN    364>>IF
FUNNY_PTR
       207**DCL       208--REDEF     264<<ASSIGN
NEG_RESULT
       259**DCL       279<<ASSIGN    287<<ASSIGN    330>>IF        333<<ASSIGN    359>>IF        361<<ASSIGN
       380>>IF
NORMAL_RETURN
       379**LABEL     338--GOTO      366--GOTO
OLDVAL
       262**DCL       343<<ASSIGN    353>>IF        353>>IF        355<<ASSIGN
ORD_CHAR
       213**DCL       346<<ASSIGN    347>>IF        348>>ASSIGN
OVERFLOW
       245**DCL       315<<ASSIGN    354<<ASSIGN    354>>ASSIGN    359>>IF        362<<ASSIGN    362>>ASSIGN
       365>>IF
OVERFLOW_RETURN
       374**LABEL     331--CALLALT   335--CALLALT   365--GOTO
POS_INFINITY
       255**DCL       256--REDEF     376<>CALL
RESULT
       258**DCL       312<<ASSIGN    331<>CALL      335<>CALL      358<<ASSIGN    359>>IF        360>>IF
       380<<ASSIGN    380>>ASSIGN    381<>CALL
PL6.E3A0      #008=STRTOUL File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:57   
SEARCH_TABLE
       221**DCL       274>>CALLBLT
START
       237**DCL       314<<ASSIGN    318>>CALLBLT   324>>ASSIGN    331>>CALL      335>>CALL
STRING
       203**DCL         7--PROC      266<>CALL      274>>CALLBLT   295>>ASSIGN    318>>CALLBLT   331<>CALL
       335<>CALL      346>>ASSIGN    370--ASSIGN    374--ASSIGN    379--ASSIGN
STRING_INDEX
       210**DCL       274<<CALLBLT   285<<ASSIGN    285>>ASSIGN    288<<ASSIGN    288>>ASSIGN    295>>ASSIGN
       298<<ASSIGN    298>>ASSIGN    305<<ASSIGN    305>>ASSIGN    313>>ASSIGN    318<<CALLBLT   324>>ASSIGN
       346>>ASSIGN    351<<ASSIGN    351>>ASSIGN    364>>IF        374>>ASSIGN    379>>ASSIGN
STRING_LEN
       204**DCL       203--IMP-SIZ   266>>CALL      266<>CALL      267<<ASSIGN    267>>ASSIGN    274>>CALLBLT
       295>>ASSIGN    318>>CALLBLT   331>>CALL      335>>CALL      346>>ASSIGN    374>>ASSIGN    379>>ASSIGN
STRING_LENGTH
       211**DCL       324<<ASSIGN    325>>IF        331<>CALL      335<>CALL
SUB
       205**DCL         7--PROC      370--IF        370<<ASSIGN    374--IF        374<<ASSIGN    379--IF
       379<<ASSIGN
TABLE_VALUE
       238**DCL       274<<CALLBLT   280>>DOCASE
TEMP_CHAR
       212**DCL       302<<ASSIGN    303>>IF        303>>IF
TEMP_INT
       214**DCL       348<<ASSIGN    349>>IF        352>>ASSIGN
TEMP_STR
       260**DCL       295<<ASSIGN    296>>IF        296>>IF        301>>IF        302>>ASSIGN
TEMP_UBIN
       246**DCL       318<<CALLBLT
VAL
       261**DCL       344<<ASSIGN    352<<ASSIGN    352>>ASSIGN    353>>IF        355>>ASSIGN    358>>ASSIGN
XB$ERR$ASSERTION_FAILURE
        68**DCL       291<>CALL
XB$ERR$BAD_BASE
        65**DCL       270<>CALL
XB$ERR$RANGE_ERROR
PL6.E3A0      #008=STRTOUL File=xb_stdlib:6.:XBC3TSI                             FRI 01/06/95 11:23 Page:58   
        76**DCL       375<>CALL
XB$ERR$SCAN_MISMATCH
        82**DCL       282<>CALL      326<>CALL
XB$ERR$STRING_TOO_LONG
        80**DCL       276<>CALL      320<>CALL
XBI$DIGIT_VALUE_TABLE
       239**DCL       348>>ASSIGN
XBI$NON_DIGIT_TABLE
       242**DCL       318>>CALLBLT
XBI$STRLEN
       253**DCL-ENT   266--CALL
XBI_SET_ERRNO
       251**DCL-ENT   270--CALL      276--CALL      282--CALL      291--CALL      320--CALL      326--CALL
       375--CALL
XB_IO_ERROR
       252**DCL-ENT   292--CALL
XB_RETURN_ORDINAL_RESULT
       248**DCL-ENT   371--CALL      376--CALL      381--CALL
XPN_7LS0TOU
       250**DCL-ENT   331--CALL
XPN_7NS0TOU
       249**DCL-ENT   335--CALL

PL6.E3A0      #009=ZEXIT File=xb_stdlib:6.:XBC3TSI                               FRI 01/06/95 11:23 Page:59   
      895        1        /*T***********************************************************/
      896        2        /*T*                                                         */
      897        3        /*T* Copyright (c) Bull HN Information Systems Inc., 1989    */
      898        4        /*T*                                                         */
      899        5        /*T***********************************************************/
      900        6
      901        7        Zexit : PROC (status);
      902        8
      903        9        /*D* NAME: _exit
      904       10             PROTOTYPE:   void _exit(int status);
      905       11             DESCRIPTION: The _exit function terminates the calling process
      906       12                          without flushing any of the buffered I/O.  Otherwise
      907       13                          it is equivalent to the exit() function.
      908       14
      909       15                          _exit does not return.
      910       16
      911       17              WGE September  6, 1990
      912       18        */
      913       19
      914       20        %INCLUDE CP_6;
      915     5580        %INCLUDE CP_6_SUBS;
      916     6120        %INCLUDE xb_stdio_i6;
      917     6363
      918     6364
      919     6365        /*    Parameter declarations  */
      920     6366
      921     6367    1   DCL   status         SBIN;
      922     6368
      923     6369        /*    Local variables         */
      924     6370
      925     6371    1   DCL   current_stream$   PTR;
      926     6372
      927     6373    1   DCL   STDIN_P           PTR   SYMREF;
      928     6374    1   DCL   STDOUT_P          PTR   SYMREF;
      929     6375    1   DCL   STDERR_P          PTR   SYMREF;
      930     6376
      931     6377        %File_Header (Name=F, Stclass="BASED (current_stream$)");
PL6.E3A0      #009=ZEXIT File=xb_stdlib:6.:XBC3TSI                               FRI 01/06/95 11:23 Page:60   
      932     6489
      933     6490        /*    Procedure declarations  */
      934     6491
      935     6492    1   DCL   XBI_EXIT          ENTRY(1);
      936     6493
      937     6494        /*    Time to make the donuts...  What we have to do is pretend that
      938     6495              all the files buffers have not been modified.  All we do is
      939     6496              loop through the list of all the open files and lie to it
      940     6497              and set the buffer_is_modified field to 0.  Then we just
      941     6498              continue on just like it was a call to exit().                */
      942     6499
      943     6500    1      current_stream$ = XBI$FIRST_FILE_HEADER;
      944     6501    2      DO WHILE (current_stream$ ~= ADDR(NIL));
      945     6502    2         F.is_buffer_modified = '0'B;
      946     6503    2         current_stream$ = F.next_file_header;
      947     6504    2      END;
      948     6505
      949     6506        /*    Since stdin, stdout, and stderr are not linked in to this
      950     6507              chain, they must be done explicitly                           */
      951     6508
      952     6509    1      current_stream$ = STDIN_P;
      953     6510    1      F.is_buffer_modified = '0'B;
      954     6511
      955     6512    1      current_stream$ = STDOUT_P;
      956     6513    1      F.is_buffer_modified = '0'B;
      957     6514
      958     6515    1      current_stream$ = STDERR_P;
      959     6516    1      F.is_buffer_modified = '0'B;
      960     6517
      961     6518    1      CALL XBI_EXIT (status);
      962     6519
      963     6520    1   END Zexit;

PL6.E3A0      #009=ZEXIT File=xb_stdlib:6.:XBC3TSI                               FRI 01/06/95 11:23 Page:61   
--  Include file information  --

   xb_stdio_i6.:XBC3TOU  cannot be made into a system file and is referenced.
   CP_6_SUBS.:LIB_E04  is referenced.
   CP_6_C.:LIB_E04  is referenced.
   CP_6.:LIB_E04  cannot be made into a system file and is referenced.
      No diagnostics issued in procedure ZEXIT.

   Procedure ZEXIT requires 32 words for executable code.
   Procedure ZEXIT requires 6 words of local(AUTO) storage.

    No errors detected in file xb_stdlib:6.:XBC3TSI    .

PL6.E3A0      #009=ZEXIT File=xb_stdlib:6.:XBC3TSI                               FRI 01/06/95 11:23 Page:62   
          *** CROSS REFERENCE LISTING ***
**     DENOTES     IDENTIFIER DEFINITION
<<                 IDENTIFIER'S VALUE SET
>>                 IDENTIFIER'S VALUE USED
<>                 IDENTIFIER SET AND/OR USED
--                 IDENTIFIER REFERENCED
PL6.E3A0      #009=ZEXIT File=xb_stdlib:6.:XBC3TSI                               FRI 01/06/95 11:23 Page:63   
          MINI XREF LISTING

CURRENT_STREAM$
      6371**DCL      6378--IMP-PTR  6500<<ASSIGN   6501>>DOWHILE  6502>>ASSIGN   6503<<ASSIGN   6503>>ASSIGN
      6509<<ASSIGN   6510>>ASSIGN   6512<<ASSIGN   6513>>ASSIGN   6515<<ASSIGN   6516>>ASSIGN
F.FPT_READ.V.DVBYTE.REREAD#
      6440**DCL      6441--REDEF
F.FPT_READ.V.INDX#
      6433**DCL      6434--REDEF
F.FPT_WRITE.V.DVBYTE.VFC#
      6478**DCL      6479--REDEF
F.IS_BUFFER_MODIFIED
      6382**DCL      6502<<ASSIGN   6510<<ASSIGN   6513<<ASSIGN   6516<<ASSIGN
F.NEXT_FILE_HEADER
      6406**DCL      6503>>ASSIGN
STATUS
      6367**DCL         7--PROC     6518<>CALL
STDERR_P
      6375**DCL      6515>>ASSIGN
STDIN_P
      6373**DCL      6509>>ASSIGN
STDOUT_P
      6374**DCL      6512>>ASSIGN
XBI$FIRST_FILE_HEADER
      6138**DCL      6500>>ASSIGN
XBI_EXIT
      6492**DCL-ENT  6518--CALL
