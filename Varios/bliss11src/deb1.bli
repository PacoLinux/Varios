! File:   DEB1.BLI
!
!    This work was supported by the Advanced Research
!    Projects Agency of the Office of the Secretary of
!    Defense (F44620-73-C-0074) and is monitored by the
!    Air Force Office of Scientific Research.

MODULE DEB1(TIMER=EXTERNAL(SIX12))=
BEGIN
SWITCHES NOLIST;
REQUIRE COMMON.BEG;
REQUIRE IOMACS.BEG;
REQUIRE GTST.BEG;
REQUIRE ST.BEG;
REQUIRE GTX.BEG;
REQUIRE LDSFT.BEG;
REQUIRE LDSF.BEG;
REQUIRE ONCDEB.BEG;
REQUIRE STRUCT.BEG;
REQUIRE FLOW.BEG;
REQUIRE DTC.BEG;
REQUIRE TN.BEG;
SWITCHES LIST;
BEGIN
REQUIRE DEBUG.BEG;

EXTERNAL PADDR;

STRUCTURE NODENAMES[I,J]=ST[.(.NODENAMES)<0,18>,NODEX]<.I,.J>;


FORWARD GTPRINT;

OWN GTPRTYP;

GLOBAL ROUTINE LFP=
    BEGIN LOCAL SAV[16];
    SAVALL;
    GTPRTYP_1;
    GTPRINT(.SYM,1);
    CRLF;
    RESALL
    END;

GLOBAL ROUTINE CFP=
    BEGIN LOCAL SAV[16];
    SAVALL;
    GTPRTYP_0;
    GTPRINT(.SYM,1);
    CRLF;
    RESALL
    END;


ROUTINE GTPRINT(LEX,NUMBLANKS)=

	! ABBREVIATED VERSION OF TREE FOR CONTROL FLOW DEBUGGING

  BEGIN
	MACRO
	  MAX(X,Y)=IF X GTR Y THEN X ELSE Y$,
	  OUTINDEX=(OUTPUT("[");
		      OUTNUM(.LEX<0,18>,8,1);
		      OUTPUT("]"); OUTBLANK(2))$,
	  OUTTEMPNAME=(OUTPUT("(");OUTNUM(.NODE[REGF],8,1);OUTPUT(")");OUTBLANK(2))$,
	  OUTOPERANDS=INCR I FROM OPRNDOFFSET TO
			OPRNDOFFSET-1+.NODE[NODESIZEF]
			  DO GTPRINT(.NODE[.I,LEXW],.NUMBLANKS+2)$,
	  OUTMARKBIT(F,S)=IF .NODE[F] THEN (OUTSSTR(S,2); OUTBLANK(1))
			  ELSE OUTBLANK(3)$;
%%%
    ROUTINE OUTINTFLOLST (STRING,HDR,NBLANKS)=
      BEGIN
	MAP LSTHDR HDR;
	REGISTER ITEM L, ENTPERLINE,FIRSTLINE;
	LOCAL INDEX[9],ENTSIZE,THISONE,NUMSPACES,THISLINE;
	NUMSPACES_(IF .TTYLST THEN 72 ELSE 130)-(.NBLANKS+7);
	ENTPERLINE_.NUMSPACES/14-1;
	IF .ENTPERLINE LSS 0 THEN RETURN OUTSSTR('USE LPT',7);
	OUTBLANK(.NBLANKS);
	OUTXSTRING(STRING<29,7>,5,5);
	IF EMPTY(.HDR) THEN
	  (OUTBLANK(1); OUTSSTR('EMPTY',5); CRLF; RETURN);
	HDR_.HDR[BASE]; L_.HDR[RLINK];
	FIRSTLINE_-1;
	WHILE .L NEQ .HDR DO
	  BEGIN
	    ENTSIZE_0;
	    THISLINE_
	      INCR I FROM 0 TO .ENTPERLINE DO
		BEGIN
		  INDEX[.I]_.L;
		  ENTSIZE_MAX(.ENTSIZE,.L[ITEMSIZEF]-1);
		  IF (L_.L[RLINK]) EQL .HDR THEN EXITLOOP .I
		END;
	    IF .THISLINE LSS 0 THEN THISLINE_.ENTPERLINE;
	    INCR I FROM 1 TO .ENTSIZE DO
	      BEGIN
		IF NOT .FIRSTLINE THEN OUTBLANK(.NBLANKS+7) ELSE FIRSTLINE_0;
		INCR J FROM 0 TO .THISLINE DO
		  BEGIN
		    BIND ITEM L1=INDEX[.J];
		    THISONE_14-
		      (IF .I LEQ .L1[ITEMSIZEF]-1 THEN
			(OUTBLANK(1)+OUTNUM(.L1[LDATITEM(.I)],8,1)+
			 OUTPUT(",")+OUTNUM(.L1[RDATITEM(.I)],8,1)+1)
		       ELSE 0);
		    OUTBLANK(.THISONE)
		  END;
		CRLF
	      END;
	    CRLF
	  END;
      END;

%%%
%%%
    ROUTINE OUTFLOLST(STRING,HDR,NUMBLANKS)=
		BEGIN
		  MAP LSTHDR HDR;
		  REGISTER NUMSPACES, ITEM L, THISLINE;
		  NUMSPACES_ (IF .TTYLST THEN 72 ELSE 130)-(.NUMBLANKS+7);
		  IF .NUMSPACES LSS 14 THEN RETURN OUTSSTR('USE LPT',7);
		  OUTBLANK(.NUMBLANKS);
		  OUTXSTRING(STRING<29,7>,5,5);
		  IF EMPTY(.HDR) THEN
		    (OUTBLANK(1); OUTSSTR('EMPTY',5); CRLF; RETURN);
		  HDR_.HDR[BASE]; L_.HDR[RLINK]; THISLINE_14;
		  DO
		    BEGIN
		      IF .THISLINE GTR .NUMSPACES THEN
			(CRLF; OUTBLANK(.NUMBLANKS+7); THISLINE_14);
		      THISLINE_.THISLINE +
			(OUTBLANK(1) + OUTNUM(.L[LDATITEM(1)],8,1) +
			 OUTPUT(",") + OUTNUM(.L[RDATITEM(1)],8,1) +1);
		    END WHILE (L_.L[RLINK]) NEQ .HDR;
		  CRLF
		END;

%%%
    ROUTINE OUTINTFLOLST(STRING,HDR,NUMBLANKS,T)=
		BEGIN
		  MAP LSTHDR HDR;
		  REGISTER NUMSPACES, ITEM L:Q, THISLINE;
		  NUMSPACES_ (IF .TTYLST THEN 72 ELSE 130)-(.NUMBLANKS+7);
		  IF .NUMSPACES LSS 14 THEN RETURN OUTSSTR('USE LPT',7);
		  OUTBLANK(.NUMBLANKS);
		  OUTXSTRING(STRING<29,7>,5,5);
		  IF EMPTY(.HDR) THEN
		    (OUTBLANK(1); OUTSSTR('EMPTY',5); CRLF; RETURN);
		  HDR_.HDR[BASE]; L_.HDR[RLINK]; THISLINE_7;
		  DO
		    BEGIN MACRO ITERATE=EXITBLOCK$;
		      CRLF; OUTBLANK(.NUMBLANKS+4);
		      OUTPUT("("); OUTNUM(.L,8,1);
		      OUTPUT(")"); OUTBLANK(1);
		      OUTNUM(.L[LDATITEM(1)],8,1);
		      OUTPUT(":"); OUTBLANK(1);
		      THISLINE_14;
		      IF .T EQL 1 THEN
			BEGIN
			  INCR I FROM 1 TO .L[ITEMSIZEF] DO
			    BEGIN
			      IF .THISLINE GTR .NUMSPACES THEN
				(CRLF; OUTBLANK(.NUMBLANKS+14); THISLINE_14);
			      Q_.L[INTDATITEM(.I)];
			      THISLINE_.THISLINE +
				(OUTBLANK(1)+
				 (IF .Q<17,1> THEN
				   (OUTPUT("(");0) +
				   OUTNUM(.Q<0,17>,8,1)+
				   (OUTPUT(")");2)
				 ELSE OUTNUM(.Q<0,18>,8,1)));
			    END;
			  ITERATE
			END;
		      IF .L[CHAINHEAD] THEN
			(OUTPUT("(");OUTNUM(.L[INTCHAINF],8,1);
			 OUTPUT(")"))
		      ELSE OUTNUM(.L[CHAINF],8,1);
		      IF .T EQL 0 THEN
			(OUTPUT(","); OUTNUM(.L[DATITEM(2)],8,1));
		    END WHILE (L_.L[RLINK]) NEQ .HDR;
		  CRLF
		END;

    BIND NODENAMES NAMEN=LEX, FLOLSTPTR NODEPTR=LEX, GTVEC NODE=LEX;

    MAP LEXEME LEX;

    LOCAL B,LEXEME OP1LEX, GTVEC PARENT; BIND STVEC OP1NODE=OP1LEX;

    OUTNUM(.NUMBLANKS/2,8,2);

    IF .LEX EQL 0 THEN
	(OUTBLANK(.NUMBLANKS); OUTSSTR('RELEASED!',9); RETURN CRLF);

    SELECT .LEX[LTYPF] OF
     NSET

    ALPHAT:
	RETURN OUTINTFLOLST('!ALPH',.LEX[ADDRF],.NUMBLANKS,1);

    RHOT:
	RETURN OUTINTFLOLST('!RHO ',.LEX[ADDRF],.NUMBLANKS,0);

    CHIT:
	RETURN (OUTINTFLOLST('!CHI ',.LEX[ADDRF],.NUMBLANKS,2));

    OMEGAT:
	RETURN OUTINTFLOLST('!OMEG',.LEX[ADDRF],.NUMBLANKS,1);

    ALWAYS: (OUTBLANK(.NUMBLANKS); B_0);

    SELTYP:
	RETURN (IF .LEX[ADDRF]
		  THEN OUTSSTR('ALWAYS:',7)
		  ELSE OUTSSTR('OTHERWISE:',10);
		CRLF);

    LITTYP:
      BEGIN
	OUTSSTR('L=',2);
	OUTNUM(LITVALUE(.LEX[ADDRF]),8,1);
	CRLF;
	RETURN
      END;

    BNDVAR:
      BEGIN
	OUTXSTRING(NT[.NODE[NAMEPTR],ACCUM1]<29,7>,10,1);
	IF ISSTVAR(NODE) THEN IF .NODE[NAMEXP] THEN
	    BEGIN
	    LOCAL STVEC X;
	    X_.NODE[NAMEXPTR];
	    OUTPUT("+");
	    OUTNUM(LITVALUE(.NODE[OFFSETF]-.X[OFFSETF]),8,1);
	    END;
	CRLF;
	RETURN
      END;

    LSLEXTYP:
	(OUTSSTR('STRING: ',8);
	 OUTOCT(.LEX[ADDRF],1);
	 RETURN CRLF);

    TNTYP:
	(OUTSSTR('TEMP NAME: ',11);
	 OUTOCT(.LEX[ADDRF],1);
	 RETURN CRLF)

     TESN;

    IF .NODE[NODEX] LEQ MAXOPERATOR THEN
      BEGIN
	OP1LEX_.NODE[DOTTEDTHING];
	IF .NODE[NODEX] EQL SDOTOP AND
	  .OP1LEX[LTYPF] EQL BNDVAR THEN
	    BEGIN
	      B_1;
	      OUTPUT(".");
	      OUTXSTRING(NT[.OP1NODE[NAMEPTR],ACCUM1]<29,7>,10,1);
	      OUTBLANK(1);
	    END
	ELSE OUTXSTRING(OPPRNT[.NODE[NODEX]]<29,7>,5,3);
      END
    ELSE OUTXSTRING(OBPRNT[.NODE[NODEX]]<29,7>,5,5);

    OUTINDEX;
    IF .NODE[REGF] GEQ 8 THEN OUTTEMPNAME;
%%%
    IF .NODE[CSP] THEN
      BEGIN
	OUTMARKBIT(JM,'JM');
	OUTMARKBIT(RM,'RM');
	OUTMARKBIT(MM,'MM');
	OUTBLANK(2);
	OUTSSTR('MKL=',4);
	OUTNUM(.NODE[MKLEVEL],8,1);
	OUTBLANK(1);
	OUTSSTR(' CRL=',5);
	OUTNUM(.NODE[CRLEVEL],8,1);
	OUTSSTR(' OCC=',5);
	OUTNUM(.NODE[OCCF],8,1);
      END
    ELSE	%%%
    CASE .GTPRTYP OF
      SET

	! 0 - CFP
	BEGIN
	PARENT_.NODE[CSPARENT];
	IF NOT .PARENT[CSP] THEN PARENT_.PARENT[CSPARENT];
	IF .NODE[MUSTGENCODE] THEN OUTSSTR(' -<>-',5);
	IF .PARENT[OCCF] GTR 1 THEN
	    BEGIN
	    OUTSSTR('CSP= ',5); OUTPUT("[");
	    OUTNUM(.PARENT,8,1);OUTPUT("]");
	    OUTSSTR(' USE=',5); OUTNUM(.PARENT[OCCF],8,1);
	    END;
	END;

	! 1 - LFP
	BEGIN
	OUTPUT("["); OUTOCT(.NODE[LONF],1); OUTPUT(",");
	OUTOCT(.NODE[FONF],1); OUTPUT("]");
	END;

      TES;
    CRLF;
    IF NOT .B THEN OUTOPERANDS;
    RETURN
  END;





! THE FOLLOWING TRANSFERED FROM OLD BLISS 11 DEBUG.

    BIND
	LBRACKET="[",
	RBRACKET="]",
	SLASH="/",
	SINGLEQ="'";
    MACRO
	DEBUGR(N,B)=GLOBAL ROUTINE N=(LOCAL SAV[16]; SAVALL; (B); RESALL)$,
	NTEPR(NTIND)=OUTXSTRING(NT[NTIND,ACCUM1]<29,7>,10,1)$,
	STEPR(STIND)=NTEPR(.ST[STIND,NAMEPTR])$;

    ROUTINE OUTDLIM(DELLEX)=
	(INCR I FROM 0 TO DTSIZE-1 DO IF .DT[.I] EQL .DELLEX
	    THEN EXITLOOP DELLEX_.I; OUTDEL(.DELLEX));

    DEBUGR(PSYM,OUTSYM(.SYM));

    DEBUGR(PDEL,OUTDLIM(.DEL));

    DEBUGR(PWIND,OUTSYM(.SYM); OUTDLIM(.DEL); CRLF);






END
END
